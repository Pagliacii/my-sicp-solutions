#+title:     Exercises in SICP Chapter 1
#+author:    Jason Huang
#+email:     huangmianrui0310@outlook.com
#+date:      <2021-04-08 Thu>

#+description:  Exercises and solutions in SICP chapter 1
#+keywords:     sicp, exercises, solutions, lisp, scheme
#+language:     en
#+startup:      content
#+exclude_tags: noexport

* Chapter 1 Building Abstractions with Procedures

** Footnotes :noexport:

[fn:1] The elements of Pascal's triangle are called the /binomial coefficients/, because the \(n^{th}\) row consists of the coefficients of the terms in the expansion of \((x+y)^{n}\). This pattern for computing the coefficients appeared in Blaise Pascal's 1653 seminal work on probability theory, /Traité du triangle arithmétique/. According to [[file:references.org::ref:2][Knuth (1973)]], the same pattern appears in the /Szu-yuen Yü-chien/ ("The Precious Mirror of the Four Elements"), published by the Chinese mathematician Chu Shih-chieh in 1303, in the works of the twelfth-century Persian poet and mathematician Omar Khayyam, and in the works of the twelfth-century Hindu mathematician Bháscara Áchárya.

[fn:2] The definition of the Fibonacci numbers:

\begin{math}
\mathrm{Fib}(n) =
\begin{cases}
0 & \text{if }\space n=0, \\
1 & \text{if }\space n=1, \\
\mathrm{Fib}(n-1) + \mathrm{Fib}(n-2) & \text{otherwise}.
\end{cases}
\end{math}

[fn:3] This algorithm, which is sometimes known as the "Russian peasant method" of multiplication, is ancient. Examples of its use are found in the Rhind Papyrus, one of the two oldest mathematical documents in existence, wriite about 1700 =B.C.= (and copied from an even older document) by an Egyptian scribe named A'h-mose.

[fn:4] This exercise was suggested to us by Joe Stoy, based on an example in [[file:references.org::ref:1][Kaldewaij 1990]].

[fn:5] The intent of [[file:chapter-1-exercises.org::*Exercise 1.31][Exercise 1.31]] through [[file:chapter-1-exercises.org::*Exercise 1.33][Exercise 1.33]] is to demonstrate the expressive power that is attained by using an appropriate abstraction to consolidate many seemingly disparate operations. However, though accumulation and filtering are elegant ideas, our hands are somewhat tied in using them at this point since we do not yet have data structures to provide suitable means of combination for these abstractions. We will return to these ideas in [[file:examples.org::#section-2.2.3][Section 2.2.3]] when we show how to use /sequences/ as interfaces for combining filters and accumulators to build even more powerful abstractions. We will see there how these methods really come into their own as a powerful and elegant approach to designing programs.

[fn:6] This formula was discovered by the seventeenth-century English mathematician John Wallis.

** Exercise 1.9

Each of the following two procedures defines a method for adding two positive integers in terms of the procedures ~inc~, which increments its argument by 1, and ~dec~, which decrements its argument by 1

#+NAME: exercise1.9
#+BEGIN_SRC scheme
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
#+END_SRC

Using the substitution model, illustrate the process generated by each procedure in evaluating ~(+ 4 5)~. Are there processes iterative or recursive?

*** Solution

#+NAME: solution1.9
#+BEGIN_SRC emacs-lisp
;; Recursive
(defun + (a b)
  (if (= a 0) b (inc (+ (dec a) b))))

(+ 4 5)
;; (inc (+ (dec 4) 5))             \\       -------------
;; (inc (+ 3 5))                    \\      |           |
;; (inc (inc (+ (dec 3) 5)))         \\     |           |
;; (inc (inc (+ 2 5)))                \\    | Expansion |
;; (inc (inc (inc (+ (dec 2) 5))))     \\   |           |
;; (inc (inc (inc (+ 1 5))))            \\  |           |
;; (inc (inc (inc (inc (+ (dec 1) 5))))) || =============
;; (inc (inc (inc (inc (+ 0 5)))))      //  |           |
;; (inc (inc (inc (inc 5))))           //   |           |
;; (inc (inc (inc 6)))                //    |Contraction|
;; (inc (inc 7))                     //     |           |
;; (inc 8)                          //      |           |
;; 9                               //       -------------

;; Iterative
(defun + (a b)
  (if (= a 0) b (+ (dec a) (inc b))))

(+ 4 5)
;; (+ (dec 4) (inc 5)) ||
;; (+ 3 6)             ||
;; (+ (dec 3) (inc 6)) ||
;; (+ 2 7)             ||
;; (+ (dec 2) (inc 7)) ||
;; (+ 1 8)             ||
;; (+ (dec 1) (inc 8)) ||
;; (+ 0 9)             ||
;; 9                   ||
#+END_SRC

** Exercise 1.10

The following procedure computes a mathematical function called Ackermann's function.

#+NAME: exercise1.10-1
#+BEGIN_SRC scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
#+END_SRC

What are the values of the following expressions?

#+NAME: exercise1.10-2
#+BEGIN_SRC scheme
(A 1 10)
(A 2 4)
(A 3 3)
#+END_SRC

Consider the following procedures, where ~A~ is the procedure defined above:

#+NAME: exercise1.10-3
#+BEGIN_SRC scheme
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
#+END_SRC

Give concise mathematical definitions for the functions computed by the procedures ~f~, ~g~, and ~h~ for positive integer values of /n/. For example, ~(k, n)~ computes \(5n^2\).

*** Solution

#+NAME: solution1.10
#+BEGIN_SRC emacs-lisp :results output
(setq else 't)
(defun A (x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

(print (A 1 10)) ;; => 1024
;; (A (- 1 1) (A 1 (- 10 1))) => (A 0 (A 1 9))
;; (A 0 (A (- 1 1) (A 1 (- 9 1)))) => (A 0 (A 0 (A 1 8)))
;; (A 0 (A 0 (A (- 1 1) (A 1 (- 8 1))))) => (A 0 (A 0 (A 0 (A 1 7))))
;; (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 7 1)))))) => (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
;; (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 6 1))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 5 1)))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 4 1))))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 3 1)))))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1))))))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4)))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 4))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8))))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 8)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16)))))) => (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 16))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 32))))) => (A 0 (A 0 (A 0 (A 0 (* 2 32)))))
;; (A 0 (A 0 (A 0 (A 0 64)))) => (A 0 (A 0 (A 0 (* 2 64))))
;; (A 0 (A 0 (A 0 128))) => (A 0 (A 0 (* 2 128)))
;; (A 0 (A 0 256)) => (A 0 (* 2 256))
;; (A 0 512) => (* 2 512)
;; 1024

(print (A 2 4)) ;; => 65536
;; (A (- 2 1) (A 2 (- 4 1)))
;; (A 1 (A 2 3))
;; (A 1 (A (- 2 1) (A 2 (- 3 1))))
;; (A 1 (A 1 (A 2 2)))
;; (A 1 (A 1 (A (- 2 1) (A 2 (- 2 1)))))
;; (A 1 (A 1 (A 1 (A 2 1))))
;; (A 1 (A 1 (A 1 2)))
;; (A 1 (A 1 (A (- 1 1) (A 1 (- 2 1)))))
;; (A 1 (A 1 (A 0 (A 1 1))))
;; (A 1 (A 1 (A 0 2)))
;; (A 1 (A 1 (* 2 2)))
;; (A 1 (A 1 4))
;; (A 1 (A (- 1 1) (A 1 (- 4 1))))
;; (A 1 (A 0 (A 1 3)))
;; (A 1 (A 0 (A (- 1 1) (A 1 (- 3 1)))))
;; (A 1 (A 0 (A 0 (A 1 2))))
;; (A 1 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1))))))
;; (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
;; (A 1 (A 0 (A 0 (A 0 2))))
;; (A 1 (A 0 (A 0 (* 2 2))))
;; (A 1 (A 0 (A 0 4)))
;; (A 1 (A 0 (* 2 4)))
;; (A 1 (A 0 8))
;; (A 1 (* 2 8))
;; (A 1 16)
;; (A (- 1 1) (A 1 (- 16 1)))
;; (A 0 (A 1 15))
;; (A 0 (A (- 1 1) (A 1 (- 15 1))))
;; (A 0 (A 0 (A 1 14)))
;; (A 0 (A 0 (A (- 1 1) (A 1 (- 14 1)))))
;; (A 0 (A 0 (A 0 (A 1 13))))
;; (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 13 1))))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 12)))))
;; (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 12 1)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 11 1))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 10 1)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 9 1))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 8 1)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 7 1))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 6 1)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 5 1))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 4 1)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 3 1))))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1)))))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 4))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 8)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 16))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 32)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 64))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 128)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 256))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 512)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 1024))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
;; (A 0 (A 0 (A 0 (A 0 (* 2 2048)))))
;; (A 0 (A 0 (A 0 (A 0 4096))))
;; (A 0 (A 0 (A 0 (* 2 4096))))
;; (A 0 (A 0 (A 0 8192)))
;; (A 0 (A 0 (* 2 8192)))
;; (A 0 (A 0 16384))
;; (A 0 (* 2 16384))
;; (A 0 32768)
;; (* 2 32768)
;; 65536

(print (A 3 3)) ;; => 65536
;; (A (- 3 1) (A 3 (- 3 1)))
;; (A 2 (A 3 2))
;; (A 2 (A (- 3 1) (A 3 (- 2 1))))
;; (A 2 (A 2 (A 3 1)))
;; (A 2 (A 2 2))
;; (A 2 (A (- 2 1) (A 2 (- 2 1))))
;; (A 2 (A 1 (A 2 1)))
;; (A 2 (A 1 2))
;; (A 2 (A (- 1 1) (A 1 (- 2 1))))
;; (A 2 (A 0 (A 1 1)))
;; (A 2 (A 0 2))
;; (A 2 (* 2 2))
;; (A 2 4)
;; 65536

(defun f (n) (A 0 n))
(defun g (n) (A 1 n))
(defun h (n) (A 2 n))
#+END_SRC

#+RESULTS: solution1.10
:
: 1024
:
: 65536
:
: 65536

\begin{align}
f(n) &= 2n \\
g(n) &=
\begin{cases}
  0 & n = 0, \\
  2^{n} & n > 0
\end{cases} \\
h(n) &=
\begin{cases}
  0 & n = 0, \\
  2 & n = 1, \\
  2\textasciicircum2\textasciicircum\cdots \text{(n-1 times)} & n > 1
\end{cases}
\end{align}

** Exercise 1.11

A function /f/ is defined by the rule that

\begin{math}
f(n) = \begin{cases}
n & \text{if }\space n < 3,\\
f(n-1)+2f(n-2)+3f(n-3) & \text{if }\space n \geq 3.
\end{cases}
\end{math}

Write a procedure that computes /f/ by means of a recursive process. Write a procedure that computes /f/ by means of a iterative process.

*** Solution

#+NAME: solution1.11-recursive
#+BEGIN_SRC scheme
(define (f n)
  (if (< n 3) n
    (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))))))
(f 6)
#+END_SRC

#+RESULTS: solution1.11-recursive
: 59

#+NAME: solution1.11-iterative
#+BEGIN_SRC scheme
(define (f n) (f-iter 0 1 2 n))
(define (f-iter a b c n)
  (cond ((<= n 0) a)
        (else (f-iter b
                      c
                      (+ (* 3 a) (* 2 b) c)
                      (- n 1)))))
(f 6)
#+END_SRC

#+RESULTS: solution1.11-iterative
: 59

#+NAME: processing-f6
| n |  a |   b |   c |
|---+----+-----+-----|
| 6 |  0 |   1 |   2 |
| 5 |  1 |   2 |   4 |
| 4 |  2 |   4 |  11 |
| 3 |  4 |  11 |  25 |
| 2 | 11 |  25 |  59 |
| 1 | 25 |  59 | 142 |
| 0 | 59 | 142 | 335 |
#+TBLFM: @3$2..@>$2=@-1$+1::@3$3..@>$3=@-1$+1::@3$4..@>$4=3*@-1$-2+2*@-1$-1+@-1$0

** Exercise 1.12

The following pattern of numbers is called /Pascal's triangle/.

\begin{tabular}{lllllllll}
  &   &   &   & 1 &   &   &   &   \\
  &   &   & 1 &   & 1 &   &   &   \\
  &   & 1 &   & 2 &   & 1 &   &   \\
  & 1 &   & 3 &   & 3 &   & 1 &   \\
1 &   & 4 &   & 6 &   & 4 &   & 1 \\
  &   &   & . & . & . &   &   &
\end{tabular}

The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it[fn:1]. Write a procedure that computes elements of Pascal's triangle by means of a recursive process.

*** Solution

#+name: solution1.12-1
#+begin_src scheme
(define (pascal-triangle row col)
  (cond ((> col row) 0)
        ((< col 0) 0)
        ((= col 1) 1)
        ((+ (pascal-triangle (- row 1) (- col 1))
            (pascal-triangle (- row 1) col)))))
(pascal-triangle 5 3)
#+end_src

#+RESULTS: solution1.12-1
: 6

#+name: solution1.12-2
#+begin_src scheme :results output
(define (pascal r c)
  (if (or (= c 1) (= c r))
      1
      (+ (pascal (- r 1) (- c 1)) (pascal (- r 1) c))))
(define (display-pascal-row n)
  (define (column-iter i)
    (display (pascal n i)) (display "  ")
    (if (= i n)
        (newline)
        (column-iter (+ i 1))))
  (column-iter 1))
(define (display-pascal n)
  (define (display-pascal-iter i)
    (display-pascal-row i)
    (if (= i n)
        (newline)
        (display-pascal-iter (+ i 1))))
  (display-pascal-iter 1))
(display-pascal 5)
#+end_src

#+RESULTS: solution1.12-2
: 1
: 1  1
: 1  2  1
: 1  3  3  1
: 1  4  6  4  1
:

** Exercise 1.13

Prove that Fib(/n/) is the closest integer to \(\varphi^{n}/\sqrt{5}\), where \(\varphi = (1+\sqrt{5})/2\). Hint: Let \(\psi=(1-\sqrt{5})/2\). Use induction and the definition of the Fibonacci numbers (see Section 1.2.2[fn:2]) to prove the \(Fib(n)=(\varphi^{n}-\psi^{n})/\sqrt{5}\).

*** Solution

- [[https://codology.net/post/sicp-solution-exercise-1-13/][A simple, beautiful modern solution by Sébastien Gignoux]]
- [[https://www.evernote.com/shard/s100/sh/6a4b59d5-e99f-417c-9ef3-bcf03a4efecd/7e030d4602a0bef5df0d6dd4c2ad47bf][Another one by Lucia]]

** Exercise 1.14

Draw the tree illustrating the process generated by the ~count-change~ procedure of [[file:examples.org::#section-1.2.2][Section 1.2.2]] in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?

:count-change:
#+begin_src scheme
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination
                         kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
#+end_src
:END:

*** Solution

#+name: solution1.14
#+begin_src dot :file images/exercise-1.14.png :results output :exports code
digraph {
    graph [ ranksep=0.25 ];
    node [ shape=box, color=gray95, style=filled, penwidth=0, fontsize=9, margin=.08, width=0, height=0 ];
    edge [ penwidth=.5, arrowsize=0.5 ];

    "[0] (cc 11 5)" [ label="(cc 11 5)" ];
    "[0] (cc 11 5)" -> "[1] (cc 11 4)";  "[1] (cc 11 4)"  [ label="(cc 11 4)" ];
    "[0] (cc 11 5)" -> "[1] (cc -39 5)"; "[1] (cc -39 5)" [ label="(cc -39 5)" ];
    "[1] (cc 11 4)" -> "[2] (cc 11 3)";  "[2] (cc 11 3)"  [ label="(cc 11 3)" ];
    "[1] (cc 11 4)" -> "[2] (cc -14 4)"; "[2] (cc -14 4)" [ label="(cc -14 4)" ];
    "[2] (cc 11 3)" -> "[3] (cc 11 2)";  "[3] (cc 11 2)"  [ label="(cc 11 2)" ];
    "[2] (cc 11 3)" -> "[3] (cc 1 3)";   "[3] (cc 1 3)"   [ label="(cc 1 3)" ];
    "[3] (cc 11 2)" -> "[4] (cc 11 1)";  "[4] (cc 11 1)"  [ label="(cc 11 1)" ];
    "[3] (cc 11 2)" -> "[4] (cc 6 2)";   "[4] (cc 6 2)"   [ label="(cc 6 2)" ];
    "[3] (cc 1 3)"  -> "[4] (cc 1 2)";   "[4] (cc 1 2)"   [ label="(cc 1 2)" ];
    "[3] (cc 1 3)"  -> "[4] (cc -9 3)";  "[4] (cc -9 3)"  [ label="(cc -9 3)" ];
    "[4] (cc 11 1)" -> "[5] (cc 11 0)";  "[5] (cc 11 0)"  [ label="(cc 11 0)" ];
    "[4] (cc 11 1)" -> "[5] (cc 10 1)";  "[5] (cc 10 1)"  [ label="(cc 10 1)" ];
    "[4] (cc 6 2)"  -> "[5] (cc 6 1)";   "[5] (cc 6 1)"   [ label="(cc 6 1)" ];
    "[4] (cc 6 2)"  -> "[5] (cc 1 2)";   "[5] (cc 1 2)"   [ label="(cc 1 2)" ];
    "[4] (cc 1 2)"  -> "[5] (cc 1 1)";   "[5] (cc 1 1)"   [ label="(cc 1 1)" ];
    "[4] (cc 1 2)"  -> "[5] (cc -4 2)";  "[5] (cc -4 2)"  [ label="(cc -4 2)" ];
    "[5] (cc 10 1)" -> "[6] (cc 10 0)";  "[6] (cc 10 0)"  [ label="(cc 10 0)" ];
    "[5] (cc 10 1)" -> "[6] (cc 9 1)";   "[6] (cc 9 1)"   [ label="(cc 9 1)" ];
    "[5] (cc 6 1)"  -> "[6] (cc 6 0)";   "[6] (cc 6 0)"   [ label="(cc 6 0)" ];
    "[5] (cc 6 1)"  -> "[6] (cc 5 1)";   "[6] (cc 5 1)"   [ label="(cc 5 1)" ];
    "[5] (cc 1 2)"  -> "[6] (cc 1 1)";   "[6] (cc 1 1)"   [ label="(cc 1 1)" ];
    "[5] (cc 1 2)"  -> "[6] (cc -4 2)";  "[6] (cc -4 2)"  [ label="(cc -4 2)" ];
    "[5] (cc 1 1)"  -> "[6] (cc 1 0)";   "[6] (cc 1 0)"   [ label="(cc 1 0)" ];
    "[5] (cc 1 1)"  -> "[6] (cc 0 1)";   "[6] (cc 0 1)"   [ label="(cc 0 1)", color=gray80 ];
    "[6] (cc 9 1)"  -> "[7] (cc 9 0)";   "[7] (cc 9 0)"   [ label="(cc 9 0)" ];
    "[6] (cc 9 1)"  -> "[7] (cc 8 1)";   "[7] (cc 8 1)"   [ label="(cc 8 1)" ];
    "[6] (cc 5 1)"  -> "[7] (cc 5 0)";   "[7] (cc 5 0)"   [ label="(cc 5 0)" ];
    "[6] (cc 5 1)"  -> "[7] (cc 4 1)";   "[7] (cc 4 1)"   [ label="(cc 4 1)" ];
    "[6] (cc 1 1)"  -> "[7] (cc 1 0)";   "[7] (cc 1 0)"   [ label="(cc 1 0)" ];
    "[6] (cc 1 1)"  -> "[7] (cc 0 1)";   "[7] (cc 0 1)"   [ label="(cc 0 1)", color=gray80 ];
    "[7] (cc 8 1)"  -> "[8] (cc 8 0)";   "[8] (cc 8 0)"   [ label="(cc 8 0)" ];
    "[7] (cc 8 1)"  -> "[8] (cc 7 1)";   "[8] (cc 7 1)"   [ label="(cc 7 1)" ];
    "[7] (cc 4 1)"  -> "[8] (cc 4 0)";   "[8] (cc 4 0)"   [ label="(cc 4 0)" ];
    "[7] (cc 4 1)"  -> "[8] (cc 3 1)";   "[8] (cc 3 1)"   [ label="(cc 3 1)" ];
    "[8] (cc 7 1)"  -> "[9] (cc 7 0)";   "[9] (cc 7 0)"   [ label="(cc 7 0)" ];
    "[8] (cc 7 1)"  -> "[9] (cc 6 1)";   "[9] (cc 6 1)"   [ label="(cc 6 1)" ];
    "[8] (cc 3 1)"  -> "[9] (cc 3 0)";   "[9] (cc 3 0)"   [ label="(cc 3 0)" ];
    "[8] (cc 3 1)"  -> "[9] (cc 2 1)";   "[9] (cc 2 1)"   [ label="(cc 2 1)" ];
    "[9] (cc 6 1)"  -> "[10] (cc 6 0)";  "[10] (cc 6 0)"  [ label="(cc 6 0)" ];
    "[9] (cc 6 1)"  -> "[10] (cc 5 1)";  "[10] (cc 5 1)"  [ label="(cc 5 1)" ];
    "[9] (cc 2 1)"  -> "[10] (cc 2 0)";  "[10] (cc 2 0)"  [ label="(cc 2 0)" ];
    "[9] (cc 2 1)"  -> "[10] (cc 1 1)";  "[10] (cc 1 1)"  [ label="(cc 1 1)" ];
    "[10] (cc 5 1)" -> "[11] (cc 5 0)";  "[11] (cc 5 0)"  [ label="(cc 5 0)" ];
    "[10] (cc 5 1)" -> "[11] (cc 4 1)";  "[11] (cc 4 1)"  [ label="(cc 4 1)" ];
    "[10] (cc 1 1)" -> "[11] (cc 1 0)";  "[11] (cc 1 0)"  [ label="(cc 1 0)" ];
    "[10] (cc 1 1)" -> "[11] (cc 0 1)";  "[11] (cc 0 1)"  [ label="(cc 0 1)", color=gray80 ];
    "[11] (cc 4 1)" -> "[12] (cc 4 0)";  "[12] (cc 4 0)"  [ label="(cc 4 0)" ];
    "[11] (cc 4 1)" -> "[12] (cc 3 1)";  "[12] (cc 3 1)"  [ label="(cc 3 1)" ];
    "[12] (cc 3 1)" -> "[13] (cc 3 0)";  "[13] (cc 3 0)"  [ label="(cc 3 0)" ];
    "[12] (cc 3 1)" -> "[13] (cc 2 1)";  "[13] (cc 2 1)"  [ label="(cc 2 1)" ];
    "[13] (cc 2 1)" -> "[14] (cc 2 0)";  "[14] (cc 2 0)"  [ label="(cc 2 0)" ];
    "[13] (cc 2 1)" -> "[14] (cc 1 1)";  "[14] (cc 1 1)"  [ label="(cc 1 1)" ];
    "[14] (cc 1 1)" -> "[15] (cc 1 0)";  "[15] (cc 1 0)"  [ label="(cc 1 0)" ];
    "[14] (cc 1 1)" -> "[15] (cc 0 1)";  "[15] (cc 0 1)"  [ label="(cc 0 1)", color=gray80 ];
}
#+end_src

#+RESULTS:
[[file:images/exercise-1.14.png]]

** Exercise 1.15

The sine of an angle (specified in radians) can be computed by making use of the approximation \(\sin x \approx x\) if x is sufficiently small, and the trigonometric identity

\[\sin x=3\sin\frac{x}{3}-4\sin^{3}\frac{x}{3}\]

to reduce the size of the argument of sin. (For purposes of this exercise an angle is considered "sufficiently small" if its magnitude is not greater than 0.1 radians.) These ideas are incorporated in the following procedures:

#+begin_src scheme
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
#+end_src

a. How many times is the procedure ~p~ applied when ~(sine 12.15)~ is evaluated?
b. What is the order or growth in space and number of steps (as a function of ~a~) used by the process generated by the ~sine~ procedure when ~(sine a)~ is evaluated?

*** Solution

#+name: solution1.15-a
#+begin_src scheme
(sine 12.15)                    ; |12.15| > 0.1
(p (sine (/ 12.15 3.0)))
(p (sine 4.05))                 ; |4.05| > 0.1
(p (p (sine (/ 4.05 3.0))))
(p (p (sine 1.35)))             ; |1.35| > 0.1
(p (p (p (sine (/ 1.35 3.0)))))
(p (p (p (sine 0.45))))         ; |0.45| > 0.1
(p (p (p (p (sine (/ 0.45 3.0))))))
(p (p (p (p (sine 0.15)))))     ; |0.15| > 0.1
(p (p (p (p (p (sine (/ 0.15 3.0)))))))
(p (p (p (p (p (sine 0.05)))))) ; |0.05| < 0.1
(p (p (p (p (p 0.05)))))        ; applied 5 times
#+end_src

\[\Theta(\log (a))\]

** Exercise 1.16

Design a procedure that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does ~fast-expt~. (Hint: Using the observation that \((b^{n/2})^2=(b^{2})^{n/2}\), keep, along with the exponent /n/ and the base /b/, and additional state variable /a/, and define the state transformation in such a way that the product \(ab^{n}\) is unchanged from state to state. At the beginning of the process /a/ is taken to be 1, and the answer is given by the value of /a/ at the end of the process. In general, the technique of defining an /invariant quantity/ that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.)

*** Solution

When /n/ is even, we can rewrite the equation \(ab^{n}\) as:
\begin{align*}
ab^{n}=a(b^{n/2})^{2}&=a(b^{2})^{n/2}=a'b^{\prime n'} \\
a'&=a \\
b'&=b^{2} \\
n'&=n/2
\end{align*}

When /n/ is odd, we can rewrite the equation \(ab^{n}\) as:
\begin{align*}
ab^{n}=abb^{n-1}&=(ab)b^{n-1}=a'b^{\prime n'} \\
a'&=ab \\
b'&=b \\
n'&=n-1
\end{align*}

#+name: solution1.16
#+begin_src scheme
(define (fast-expt b n)
  (fast-expt-iter 1 b n))
(define (fast-expt-iter a b n)
  (cond ((= n 0) a)
        ((even? n) (fast-expt-iter a (* b b) (/ n 2)))
        (else (fast-expt-iter (* a b) b (- n 1)))))
(define (even? n)
  (= (remainder n 2) 0))
(fast-expt 2 10)
#+end_src

#+RESULTS: solution1.16
: 1024

** Exercise 1.17

The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication procedure (in which it is assumed that our language can only add, not multiply) is analogous to the ~expt~ procedure:

#+name: exercise1.17
#+begin_src scheme
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
#+end_src

This algorithm takes a number of steps that is linear in ~b~. Now suppose we include, together with addition, operations ~double~, which divides an (even) integer by 2. Using these, design a multiplication procedure analogous to ~fast-expt~ that uses a logarithmic number of steps.

*** Solution

An invariant when /b/ is even is:
\begin{align*}
a \times b=a\times\left(2\times\frac{b}{2}\right)&=(2a)\times\left(\frac{b}{2}\right)=a'\times b' \\
a'&=2a \\
b'&=\frac{b}{2}
\end{align*}

#+name: solution1.17
#+begin_src scheme
(define (even? n)
  (= (remainder n 2) 0))

(define (double x)
  (* x 2))

(define (halve x)
  (/ x 2))

(define (fast-mult a b)
  (cond ((= b 0) 0)
        ((even? b) (fast-mult (double a) (halve b)))
        (else (+ a (fast-mult a (- b 1))))))

(fast-mult 17 19)
#+end_src

#+RESULTS: solution1.17
: 323

** Exercise 1.18

Using the results of [[*Exercise 1.16][Exercise 1.16]] and [[*Exercise 1.17][Exercise 1.17]], devise a procedure that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.[fn:3]

*** Solution

An invariant when /b/ is even is:
\begin{align*}
a\times b+c=a\times\left(2\times\frac{b}{2}\right)+c&=(2a)\times\left(\frac{b}{2}\right)+c=a'\times b'+c' \\
a'&=2a \\
b'&=\frac{b}{2} \\
c'&=c
\end{align*}

An invariant when /b/ is odd is:
\begin{align*}
a\times b+c=a\times(1+(b-1))+c&=a\times(b-1)+(a+c)=a'\times b'+c' \\
a'&=a \\
b'&=(b-1) \\
c'&=(a+c)
\end{align*}

/c/ is an accumulator started from 0.

#+name: solution1.18
#+begin_src scheme
(define (even? n) (= (remainder n 2) 0))
(define (double x) (* x 2))
(define (halve x) (/ x 2))

(define (mult a b)
  (define (mult-iter a b c)
    (cond ((= b 0) c)
          ((even? b) (mult-iter (double a) (halve b) c))
          (else (mult-iter a (- b 1) (+ a c)))))
  (mult-iter a b 0))

(mult 17 19)
#+end_src

#+RESULTS: solution1.18
: 323

Another invariant when /b/ is odd is:
\begin{align*}
a\times b+c=a\times(b-1)+(a+c)&=2a\times\frac{b-1}{2}+(a+c)=a'\times b'+c' \\
a'&=2a \\
b'&=\frac{b-1}{2} \\
c'&=(a+c)
\end{align*}

#+name: solution1.18-alternative
#+begin_src scheme
(define (even? n) (= (remainder n 2) 0))
(define (double x) (* x 2))
(define (halve x) (/ x 2))

(define (mult a b)
  (define (mult-iter a b c)
    (cond ((= b 0) c)
          ((even? b) (mult-iter (double a) (halve b) c))
          (else (mult-iter (double a) (halve (- b 1)) (+ a c)))))
  (mult-iter a b 0))

(mult 17 19)
#+end_src

#+RESULTS: solution1.18-alternative
: 323

** Exercise 1.19

There is a clever algorithm for computing the Fibonacci numbers in a logarithmic number of steps. Recall the transformation of the state variables \(a\) and \(b\) in the ~fib-iter~ process of [[file:examples.org::#section-1.2.2][Section 1.2.2]]: \(a\leftarrow a+b\) and \(b\leftarrow a\). Call this transformation \(T\), and observe that applying \(T\) over and over again \(n\) times, starting with 1 and 0, produces the pair \(\mathrm{Fib}(n+1)\) and \(\mathrm{Fib}(n)\). In other words, the Fibonacci numbers are produced by applying \(T^n\), the \(n^{\mathrm{th}}\) power of the transformation \(T\), starting with the pair \((1,0)\). Now consider \(T\) to be the special case of \(p=0\) and \(q=1\) in a family of transformations \(T_{pq}\), where \(T_{pq}\) transforms the pair \((a,b)\) according to \(a\leftarrow bq+aq+ap\) and \(b\leftarrow bp+aq\). Show that if we apply such a transformation \(T_{pq}\) twice, the effect is the same as using a single transformation \(T_{p'q'}\) of the same form, and compute \(p'\) and \(q'\) in terms of \(p\) and \(q\). This gives us an explicit way to square these transformations, and thus we can compute \(T^n\) using successive squaring, as in the ~fast-expt~ procedure. Put this all together to complete the following procedure, which runs in a logarithmic number of steps:[fn:4]

#+name: exercise1.19
#+begin_src scheme
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   <??>    ; compute p'
                   <??>    ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
#+end_src

*** Solution

To expand \(T_{pq}(T_{pq}(a,b))\) and refactor it as \(a\leftarrow bq' + aq' + ap'\) and \(b \leftarrow bp' + aq'\):

\begin{align*}
T_{pq}(a,b)&=(bq+aq+ap, bp+aq) \\
T_{pq}(T_{pq}(a,b))&=((bp+aq)q+(bq+aq+ap)q+(bq+aq+ap)p, (bp+aq)p+(bq+aq+ap)q) \\
T_{pq}(T_{pq}(a,b))&=(bpq+aq^2+bq^2+aq^2+apq+bpq+apq+ap^2, bp^2+apq+bq^2+aq^2+apq) \\
T_{pq}(T_{pq}(a,b))&=(b(2pq+q^2)+a(2pq+q^2)+a(p^2+q^2), b(p^2+q^2)+a(2pq+q^2))=T_{p'q'}
\end{align*}

So, we can get those equations below:

\begin{align*}
p'=p^2+q^2 \\
q'=2pq+q^2
\end{align*}

#+name: solution1.19
#+begin_src scheme
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))
                   (+ (* 2 p q) (* q q))
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(fib 17)
#+end_src

#+RESULTS: solution1.19
: 1597

** Exercise 1.20

The process that a procedure generates is of course dependent on the rules used by the interpreter. As an example, consider the iterative ~gcd~ procedure given above. Suppose we were to interpret this procedure using normal-order evaluation, as discussed in [[file:examples.org::#section-1.1.5][Section 1.1.5]]. (The normal-order-evaluation rule for ~if~ is described in Exercise 1.5.) Using the substitution method (for normal order), illustrate the process generated in evaluating ~(gcd 206 40)~ and indicate the ~remainder~ operations that are actually performed. How many ~remainder~ operations are actually performed in the normal-order evaluation of ~(gcd 206 40)~? In the applicative-order evaluation?

#+name: gcd-code
#+begin_src scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+end_src

*** Solution

#+name: gcd-normal-order-evaluation
#+begin_src scheme
(gcd 206 40)
; equals to
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))
; gets
(gcd 40 (remainder 206 40))
; equals to
(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))
; 1 * remainder
(if (= 6 0)
    40
    (gcd (remainder 206 40)
         (remainder 40 (remainder 206 40))))
; gets
(gcd (remainder 206 40)
     (remainder 40 (remainder 206 40)))
; equals to
(if (= (remainder 40 (remainder 206 40)) 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40)
                    (remainder 40 (remainder 206 40)))))
; 2 * remainder
(if (= 4 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40)
                    (remainder 40 (remainder 206 40)))))
; gets
(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40)
                (remainder 40 (remainder 206 40))))
; equals to
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))
; 4 * remainder
(if (= 2 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))
; gets
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40))
                (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
; equals to
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
                    (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))
; 7 * remainder
(if (= 0 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
                    (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))
; gets
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
; 4 * remainder
2
#+end_src

Using *normal-order evaluation*, ~remainder~ is called \(1+2+4+7+4=18\) times.

#+name: gcd-applicative-order-evaluation
#+begin_src scheme
(gcd 206 40)
; equals to
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40))) ; 1 * remainder
; gets
(gcd 40 6)
; equals to
(if (= 6 0)
    40
    (gcd 6 (remainder 40 6)))    ; 1 * remainder
; gets
(gcd 6 4)
; equals to
(if (= 4 0)
    6
    (gcd 4 (remainder 6 4)))     ; 1 * remainder
; gets
(gcd 4 2)
; equals to
(if (= 2 0)
    4
    (gcd 2 (remainder 4 2)))     ; 1 * remainder
; gets
(gcd 2 0)
; equals to
(if (= 0 0)
    2
    (gcd 0 (remainder 2 0)))
; gets
2
#+end_src

Using *applicative-order evaluation*, ~remainder~ is called 4 times.

** Exercise 1.21

Use the ~smallest-divisor~ procedure to find the smallest divisor of each of the following numbers: 199, 1999, 19999.

#+name: smallest-divisor-ex
#+begin_src scheme
(define (smallest-divisor n) (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b) (= (remainder b a) 0))

(define (square x) (* x x))
#+end_src

*** Solution

#+begin_src scheme :noweb yes :results output
<<smallest-divisor-ex>>

(display (smallest-divisor 199))
(newline)
(display (smallest-divisor 1999))
(newline)
(display (smallest-divisor 19999))
#+end_src

#+RESULTS:
: 199
: 1999
: 7

** Exercise 1.22

Most Lisp implementations include a primitive called ~runtime~ that returns an integer that specifies the amount of time the system has been running (measured, for example, in microseconds). The following ~timed-prime-test~ procedure, when called with an integer /n/, prints /n/ and checks to see if /n/ is prime. If /n/ is prime, the procedure prints three asterisks followed by the amount of time used in performing the test.

#+name: timed-prime-test
#+begin_src scheme :var num=2 :results both
(define (runtime) (current-inexact-milliseconds))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))
      "nothing"))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
#+end_src

Using this procedure, write a procedure ~search-for-primes~ that checks the primality of consecutive odd integers in a specified range. Use your procedure to find the three smallest primes larger than 1000; larger than 10,000; larger than 100,000; larger than 1,000,000. Note the time needed to test each prime. Since the testing algorithm has order of growth of \(\Theta(\sqrt{n})\), you should expect that testing for primes around 10,000 should take about \(\sqrt{10}\) times as long as testing for primes around 1000. Do your timing data bear this out? How well do the data for 100,000 and 1,000,000 support the \(\Theta(\sqrt{n})\) prediction? Is your result compatible with the notion that programs on your machine run in time proportional to the number of steps required for the computation?

*** Solution

#+name: search-for-primes
#+begin_src scheme :exports none
(define (prime? n)
  (= n (smallest-divisor n)))

(define (search-for-primes start-range end-range)
  (if (even? start-range)
      (search-for-primes (+ 1 start-range) end-range)
      (cond ((> start-range end-range)
             (newline)
             (display "done"))
            (else (timed-prime-test start-range)
                  (search-for-primes (+ 2 start-range) end-range)))))
#+end_src

#+name: solution1.22
#+begin_src scheme :noweb yes :results output
<<smallest-divisor-ex>>
<<timed-prime-test>>
<<search-for-primes>>

(search-for-primes 1000 1020)
(newline)
(search-for-primes 10000 10040)
(newline)
(search-for-primes 100000 100050)
(newline)
(search-for-primes 1000000 1000050)
#+end_src

#+RESULTS: solution1.22
#+begin_example :exports none

1001
1003
1005
1007
1009 *** 0.001953125
1011
1013 *** 0.001953125
1015
1017
1019 *** 0.001953125
done

10001
10003
10005
10007 *** 0.006103515625
10009 *** 0.006103515625
10011
10013
10015
10017
10019
10021
10023
10025
10027
10029
10031
10033
10035
10037 *** 0.005859375
10039 *** 0.0048828125
done

100001
100003 *** 0.016845703125
100005
100007
100009
100011
100013
100015
100017
100019 *** 0.01806640625
100021
100023
100025
100027
100029
100031
100033
100035
100037
100039
100041
100043 *** 0.017822265625
100045
100047
100049 *** 0.016845703125
done

1000001
1000003 *** 0.0791015625
1000005
1000007
1000009
1000011
1000013
1000015
1000017
1000019
1000021
1000023
1000025
1000027
1000029
1000031
1000033 *** 0.094970703125
1000035
1000037 *** 0.068115234375
1000039 *** 0.05615234375
1000041
1000043
1000045
1000047
1000049
done
#+end_example

** Exercise 1.23

The ~smallest-divisor~ procedure shown at the start of this section does lots of needless testing: After it checks to see if it is divisible by any larger even numbers. This suggests that the values used for ~test-divisor~ should not be \(2, 3, 4, 5, 6, \dots\), but rather \(2,3,5,7,9,\dots\). To implement this change, define a procedure ~next~ that returns 3 if its input is equal to 2 and otherwise returns its input plus 2. Modify the ~smallest-divisor~ procedure to use ~(next test-divisor)~ instead of ~(+ test-divisor 1)~. With ~timed-prime-test~ incorporating this modified version of ~smallest-divisor~, run the test for each of the 12 primes found in [[*Exercise 1.22][Exercise 1.22]]. Since this modification halves the number of test steps, you should expect it to run about twice as fast. Is this expectation confirmed? If not, what is the observed ratio of the speeds of the two algorithms, and how do you explain the fact that it is different from 2?

*** Solution

#+name: solution1.23
#+begin_src scheme :noweb yes :results output
<<smallest-divisor>>
<<timed-prime-test>>
<<search-for-primes>>

(define (next num)
  (if (= num 2) 3
      (+ 2 num)))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(search-for-primes 1000 1070)
(newline)
(search-for-primes 10000 10110)
(newline)
(search-for-primes 100000 100170)
(newline)
(search-for-primes 1000000 1000180)
#+end_src

#+RESULTS: solution1.23
#+begin_example

1001
1003
1005
1007
1009 *** 0.0009765625
1011
1013 *** 0.0009765625
1015
1017
1019 *** 0.001953125
1021 *** 0.0009765625
1023
1025
1027
1029
1031 *** 0.0009765625
1033 *** 0.0009765625
1035
1037
1039 *** 0.001953125
1041
1043
1045
1047
1049 *** 0.0009765625
1051 *** 0.0009765625
1053
1055
1057
1059
1061 *** 0.0009765625
1063 *** 0.0009765625
1065
1067
1069 *** 0.001220703125
done

10001
10003
10005
10007 *** 0.004150390625
10009 *** 0.004150390625
10011
10013
10015
10017
10019
10021
10023
10025
10027
10029
10031
10033
10035
10037 *** 0.005859375
10039 *** 0.00390625
10041
10043
10045
10047
10049
10051
10053
10055
10057
10059
10061 *** 0.00390625
10063
10065
10067 *** 0.00390625
10069 *** 0.004150390625
10071
10073
10075
10077
10079 *** 0.004150390625
10081
10083
10085
10087
10089
10091 *** 0.004150390625
10093 *** 0.00390625
10095
10097
10099 *** 0.0029296875
10101
10103 *** 0.004150390625
10105
10107
10109
done

100001
100003 *** 0.02685546875
100005
100007
100009
100011
100013
100015
100017
100019 *** 0.050048828125
100021
100023
100025
100027
100029
100031
100033
100035
100037
100039
100041
100043 *** 0.01220703125
100045
100047
100049 *** 0.010986328125
100051
100053
100055
100057 *** 0.010986328125
100059
100061
100063
100065
100067
100069 *** 0.011962890625
100071
100073
100075
100077
100079
100081
100083
100085
100087
100089
100091
100093
100095
100097
100099
100101
100103 *** 0.01220703125
100105
100107
100109 *** 0.02392578125
100111
100113
100115
100117
100119
100121
100123
100125
100127
100129 *** 0.011962890625
100131
100133
100135
100137
100139
100141
100143
100145
100147
100149
100151 *** 0.026123046875
100153 *** 0.01708984375
100155
100157
100159
100161
100163
100165
100167
100169 *** 0.027099609375
done

1000001
1000003 *** 0.036865234375
1000005
1000007
1000009
1000011
1000013
1000015
1000017
1000019
1000021
1000023
1000025
1000027
1000029
1000031
1000033 *** 0.06201171875
1000035
1000037 *** 0.052001953125
1000039 *** 0.049072265625
1000041
1000043
1000045
1000047
1000049
1000051
1000053
1000055
1000057
1000059
1000061
1000063
1000065
1000067
1000069
1000071
1000073
1000075
1000077
1000079
1000081 *** 0.0361328125
1000083
1000085
1000087
1000089
1000091
1000093
1000095
1000097
1000099 *** 0.035888671875
1000101
1000103
1000105
1000107
1000109
1000111
1000113
1000115
1000117 *** 0.035888671875
1000119
1000121 *** 0.0361328125
1000123
1000125
1000127
1000129
1000131
1000133 *** 0.072021484375
1000135
1000137
1000139
1000141
1000143
1000145
1000147
1000149
1000151 *** 0.035888671875
1000153
1000155
1000157
1000159 *** 0.035888671875
1000161
1000163
1000165
1000167
1000169
1000171 *** 0.035888671875
1000173
1000175
1000177
1000179
done
#+end_example

** Exercise 1.24

Modify the ~timed-prime-test~ procedure of [[*Exercise 1.22][Exercise 1.22]] to use ~fast-prime?~ (the Fermat method), and test each of the 12 primes you found in that exercise. Since the Fermat test has \(\Theta(\log{n})\) growth, how would you expect the time to test primes near 1,000,000 to compare with the time needed to test primes near 1000? Do your data bear this out? Can you explain any discrepancy you find?

*** Solution

#+name: solution1.24
#+begin_src scheme :noweb yes :results output
<<smallest-divisor>>
<<timed-prime-test>>
<<search-for-primes>>

<<expmod>>
<<fermat-test>>
<<fast-prime-test>>

(define (start-prime-test n start-time)
  (if (fast-prime? n 100)
      (report-prime (- (runtime) start-time))
      "nothing"))

(search-for-primes 1000 1070)
(newline)
(search-for-primes 10000 10110)
(newline)
(search-for-primes 100000 100170)
(newline)
(search-for-primes 1000000 1000180)
#+end_src

#+RESULTS: solution1.24
#+begin_example

1001
1003
1005
1007
1009 *** 0.10498046875
1011
1013 *** 0.15185546875
1015
1017
1019 *** 0.111083984375
1021 *** 0.09814453125
1023
1025
1027
1029
1031 *** 0.083984375
1033 *** 0.079833984375
1035
1037
1039 *** 0.087890625
1041
1043
1045
1047
1049 *** 11.0390625
1051 *** 0.135009765625
1053
1055
1057
1059
1061 *** 0.083984375
1063 *** 0.087890625
1065
1067
1069 *** 0.111083984375
done

10001
10003
10005
10007 *** 0.118896484375
10009 *** 0.115234375
10011
10013
10015
10017
10019
10021
10023
10025
10027
10029
10031
10033
10035
10037 *** 0.14794921875
10039 *** 0.134765625
10041
10043
10045
10047
10049
10051
10053
10055
10057
10059
10061 *** 0.119140625
10063
10065
10067 *** 0.1611328125
10069 *** 0.1181640625
10071
10073
10075
10077
10079 *** 0.1259765625
10081
10083
10085
10087
10089
10091 *** 0.1220703125
10093 *** 0.18701171875
10095
10097
10099 *** 0.168212890625
10101
10103 *** 0.195068359375
10105
10107
10109
done

100001
100003 *** 0.136962890625
100005
100007
100009
100011
100013
100015
100017
100019 *** 0.14111328125
100021
100023
100025
100027
100029
100031
100033
100035
100037
100039
100041
100043 *** 0.171142578125
100045
100047
100049 *** 0.13818359375
100051
100053
100055
100057 *** 0.16015625
100059
100061
100063
100065
100067
100069 *** 0.14208984375
100071
100073
100075
100077
100079
100081
100083
100085
100087
100089
100091
100093
100095
100097
100099
100101
100103 *** 0.136962890625
100105
100107
100109 *** 0.137939453125
100111
100113
100115
100117
100119
100121
100123
100125
100127
100129 *** 0.14794921875
100131
100133
100135
100137
100139
100141
100143
100145
100147
100149
100151 *** 0.14501953125
100153 *** 0.161865234375
100155
100157
100159
100161
100163
100165
100167
100169 *** 0.136962890625
done

1000001
1000003 *** 0.257080078125
1000005
1000007
1000009
1000011
1000013
1000015
1000017
1000019
1000021
1000023
1000025
1000027
1000029
1000031
1000033 *** 0.157958984375
1000035
1000037 *** 0.162109375
1000039 *** 0.199951171875
1000041
1000043
1000045
1000047
1000049
1000051
1000053
1000055
1000057
1000059
1000061
1000063
1000065
1000067
1000069
1000071
1000073
1000075
1000077
1000079
1000081 *** 0.158935546875
1000083
1000085
1000087
1000089
1000091
1000093
1000095
1000097
1000099 *** 0.214111328125
1000101
1000103
1000105
1000107
1000109
1000111
1000113
1000115
1000117 *** 0.1669921875
1000119
1000121 *** 0.18701171875
1000123
1000125
1000127
1000129
1000131
1000133 *** 0.1630859375
1000135
1000137
1000139
1000141
1000143
1000145
1000147
1000149
1000151 *** 0.169921875
1000153
1000155
1000157
1000159 *** 0.2880859375
1000161
1000163
1000165
1000167
1000169
1000171 *** 0.343017578125
1000173
1000175
1000177
1000179
done
#+end_example

** Exercise 1.25

Alyssa P. Hacker complains that we went to a lot extra work in writing ~expmod~. After all, she says, since we already know how to compute exponentials, we could have simple written

#+name: simple-expmod
#+begin_src scheme
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
#+end_src

Is she correct? Would this procedure serve as well for our fast prime tester? Explain.

*** Solution

[[https://codology.net/post/sicp-solution-exercise-1-25/][Solution from Sébastien Gignoux]]

** Exercise 1.26

Louis Reasoner is having great difficulty doing [[*Exercise 1.24][Exercise 1.24]]. His ~fast-prime?~ test seems to run more slowly than his ~prime?~ test. Louis calls his friend Eva Lu Ator over to help. When they examine Louis's code, they find that he has rewritten the ~expmod~ procedure to use an explicit multiplication, rather than calling ~square~:

#+name: louis-expmod
#+begin_src scheme
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base
                       (expmod base (- exp 1) m))
                    m))))
#+end_src

"I don't see what difference that could make", says Louis. "I do." says Eva. "By writing the procedure like that, you have transformed the \(\Theta(\log{n})\) process into a \(\Theta(n)\) process." Explain.

*** Solution

[[https://codology.net/post/sicp-solution-exercise-1-26/][Solution from Sébastien Gignoux]]

** Exercise 1.27

Demonstrate that the Carmichael numbers listed in Footnote 1.47 really do fool the Fermat test. That is, write a procedure that takes an integer /n/ and tests whether \(a^n\) is congruent to /a/ modulo /n/ for every \(a < n\), and try your procedure on the given Carmichael numbers.

#+name: footnote_1.47
#+begin_quote
Numbers that fool the Fermat test are called /Carmichael numbers/, and little is known about them other than that they extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a "correct" algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.
#+end_quote

*** Solution

#+name: solution1.27
#+begin_src scheme :exports none
(define (carmichael-number? n)
  (define (try-it n a)
    (cond ((= a 1) true)
          ((not (= (expmod a n n) a)) f)
          (else (try-it n (- a 1)))))
  (try-it n (- n 1)))
#+end_src

#+begin_src scheme :noweb yes :results output
(define (square x) (* x x))

<<expmod>>
<<solution1.27>>

(display (carmichael-number? 561))  (newline)
(display (carmichael-number? 1105)) (newline)
(display (carmichael-number? 1729)) (newline)
(display (carmichael-number? 2465)) (newline)
(display (carmichael-number? 2821)) (newline)
(display (carmichael-number? 6601)) (newline)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t

** Exercise 1.28

One variant of the Fermat test that cannot be fooled is called the /Miller-Rabin test/ ([[Miller 1976]]; [[Rabin 1980]]). This starts from an alternate form of Fermat's Little Theorem, which states that if /n/ is a prime number and /a/ is any positive integer less than /n/, then /a/ raised to the (n-1)-st power is congruent to 1 modulo /n/. To test the primality of a number /n/ by the Miller-Rabin test, we pick a random number /a/ < /n/ and raise /a/ to the (n-1)-st power modulo /n/ using ~expmod~ procedure. However, whenever we perform the squaring step in ~expmod~, we check to see if we have discovered a "nontrivial square root of 1 modulo /n/," that is, a number not equal to 1 or n-1 whose square is equal to 1 modulo /n/. It is possible to prove that if such a nontrivial square root of 1 exists, then /n/ is not prime. It is also possible to prove that if /n/ is an odd number that is not prime, then, for at least half the numbers /a/ < /n/, computing \(a^{n-1}\) in this way will reveal a nontrivial square root of 1 modulo /n/. (This is why the Miller-Rabin test cannot fooled.) Modify the ~expmod~ procedure to signal if it discovers a nontrivial square root of 1, and use this to implement the Miller-Rabin test with a procedure analogous to ~fermat-test~. Check your procedure by testing various known primes and non-primes. Hint: One convenient way to make ~expmod~ signal is to have it return 0.

*** Solution

#+name: miller-rabin-test
#+begin_src scheme :exports none
(define (miller-rabin-test n)
  (define (try-it a)
    (= (expmod-checked a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))
#+end_src

#+name: remainder-square-checked
#+begin_src scheme :exports none
(define (remainder-square-checked x m)
  (if (and (not (or (= x 1)
                    (= x (- m 1))))
           (= (remainder (* x x) m) 1))
      0
      (remainder (* x x) m)))
#+end_src

#+name: expmod-checked
#+begin_src scheme :exports none
(define (expmod-checked base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder-square-checked (expmod-checked base (/ exp 2) m) m))
        (else
         (remainder (* base (expmod-checked base (- exp 1) m))
                    m))))
#+end_src

#+name: miller-rabin-prime?
#+begin_src scheme :exports none
(define (miller-rabin-prime? n times)
  (cond ((= times 0) #t)
        ((miller-rabin-test n)
         (miller-rabin-prime? n (- times 1)))
        (else #f)))
#+end_src

#+name: solution1.28
#+begin_src scheme :noweb yes :results output
<<miller-rabin-test>>
<<remainder-square-checked>>
<<expmod-checked>>
<<miller-rabin-prime?>>

(define (assert-result test-name actual expected)
  (display (if (eq? actual expected) "pass: " "fail: "))
  (display test-name)
  (newline))

(assert-result "   2 is prime"     (miller-rabin-prime?    2 10) #t)
(assert-result "1009 is prime"     (miller-rabin-prime? 1009 10) #t)
(assert-result "   4 is not prime" (miller-rabin-prime?    4 10) #f)
(assert-result "  99 is not prime" (miller-rabin-prime?   99 10) #f)
(assert-result " 561 is not prime" (miller-rabin-prime?  561 10) #f)
#+end_src

#+RESULTS: solution1.28
: pass:    2 is prime
: pass: 1009 is prime
: pass:    4 is not prime
: pass:   99 is not prime
: pass:  561 is not prime

** Exercise 1.29

Simpson's Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpson's Rule, the integral of a function /f/ between /a/ and /b/ is approximated as

\[\frac{h}{3}(y_0+4y_1+2y_2+4y_3+2y_4+\cdots+2y_{n-2}+4y_{n-1}+y_n),\]

where \(h = (b-a)/n\), for some even integer /n/, and \(y_k=f(a+kh)\). (Increasing /n/ increases the accuracy of the approximation.) Define a procedure that takes as arguments /f/, /a/, /b/, and /n/ and returns the value of the integral, computed using Simpson's Rule. Use your procedure to integrate ~cube~ between 0 and 1 (with /n/ = 100 and /n/ = 1000), and compare the results to those of the ~integral~ procedure shown above.

*** Solution

The sum can be rewritten like this:

\[\frac{h}{3}(y_0+4(\underbrace{y_1+y_3+y_5+\cdots+y_{n-1}}_\text{odd terms})+2(\underbrace{y_2+y_4+y_6+\cdots+y_{n-2}}_\text{even terms})+y_n)\]

#+name: sum
#+begin_src scheme :exports none
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+end_src

#+name: integral
#+begin_src scheme :exports none
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
#+end_src

#+name: integral-simpson
#+begin_src scheme :exports none
(define (integral-simpson f a b n)
  (define h (/ (- b a) n))
  (define (add-2h x) (+ x h h))
  (* (+ (f a)
        (* 4 (sum f (+ a h) add-2h b))
        (* 2 (sum f a       add-2h b))
        (f b)) ; b = a + nh
     (/ h 3)))
#+end_src

#+name: solution1.29
#+begin_src scheme :noweb yes :results output
<<sum>>
<<integral>>
<<integral-simpson>>
(define (cube x) (* x x x))

(display (integral cube 0 1 0.01))  (newline)
(display (integral cube 0 1 0.001)) (newline)
(newline)
(display (integral-simpson cube 0 1.0 100))  (newline)
(display (integral-simpson cube 0 1.0 1000)) (newline)
#+end_src

#+RESULTS: solution1.29
: 0.24998750000000042
: 0.249999875000001
:
: 0.25000000000000044
: 0.25000000000000083

The ~integral-simpson~ gives much more accuracy for the same number of step.

** Exercise 1.30

The ~sum~ procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:

#+begin_src scheme
(define (sum term a next b)
  (define (iter a result)
    (if <??>
        <??>
        (iter <??> <??>)))
  (iter <??> <??>))
#+end_src

*** Solution

#+name: solution1.30
#+begin_src scheme :exports none
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))
#+end_src

#+begin_src scheme :noweb yes :results output
<<solution1.30>>
<<cube>>
<<inc>>
<<sum-cube-inc>>
<<identity>>
<<sum-identity-inc>>
<<sum-pi-term-next>>
<<integral>>

(display (sum-cubes 1 10))          (newline)
(display (sum-integers 1 10))       (newline)
(display (* 8 (pi-sum 1 1000)))     (newline)
(display (integral cube 0 1 0.01))  (newline)
(display (integral cube 0 1 0.001)) (newline)
#+end_src

#+RESULTS:
: 3025
: 55
: 3.139592655589782
: 0.24998750000000042
: 0.24999987500000073

** Exercise 1.31

#+ATTR_LATEX: :options [a.]
a. The ~sum~ procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures[fn:5]. Write an analogous procedure called ~product~ that returns the product of the values of a function at points over a given range. Show how to define ~factorial~ in terms of ~product~. Also use ~product~ to compute approximations to \(\pi\) using the formula[fn:6]
   \[\frac{\pi}{4}=\frac{2\cdot4\cdot4\cdot6\cdot6\cdot8\cdots}{3\cdot3\cdot5\cdot5\cdot7\cdot7\cdots}.\]

b. If your ~product~ procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.

*** Solution

**** Implementing recursive ~product~

#+name: higher-order-product
#+begin_src scheme
(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))
#+end_src

**** Implementing ~factorial~ in terms of ~product~

#+name: factorial-via-product
#+begin_src scheme :noweb yes :results output
<<higher-order-product>>
(define (identity x) x)
(define (inc x) (+ x 1))
(define (factorial num)
  (product identity 1 inc num))

(display (factorial 4)) (newline)
(display (factorial 10)) (newline)
#+end_src

#+RESULTS: factorial-via-product
: 24
: 3628800

**** Implementing Wallis' product for \(\pi\) in terms of ~product~

The formula above to compute approximations to \(\pi\) is called the *Wallis product* for \(\pi\), published in 1656 by [[https://en.wikipedia.org/wiki/John_Wallis][John Wallis]], states that

\begin{align*}
\frac{\pi}{2}&=\prod_{n=1}^{\infty} \frac{4n^2}{4n^2-1}=\prod_{n=1}^{\infty}\left(\frac{2n}{2n-1} \cdot \frac{2n}{2n-2} \right) \\
&=\left(\frac{2}{1}\cdot\frac{2}{3}\right)\cdot\left(\frac{4}{3}\cdot\frac{4}{5}\right)\cdot\left(\frac{6}{5}\cdot\frac{6}{7}\right)\cdot\left(\frac{8}{7}\cdot\frac{8}{9}\right)\cdot \cdots
\end{align*}

This formula can be implemented directly using the ~product~ function:

#+name: approximate-pi
#+begin_src scheme :noweb yes :results output
<<higher-order-product>>
(define (inc x) (+ x 1))
(define (approx-pi n)
  (define (term n)
    (* (/ (* 2 n)
          (- (* 2 n) 1))
       (/ (* 2 n)
          (+ (* 2 n) 1))))
  (* 2 (product term 1.0 inc n)))

(display (approx-pi 100))  (newline)
(display (approx-pi 1000)) (newline)
#+end_src

#+RESULTS: approximate-pi
: 3.13378749062816
: 3.140807746030383

**** Implementing iterative ~product~

#+name: iterative-higher-order-product
#+begin_src scheme :exports none
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))
#+end_src

#+begin_src scheme :noweb yes :results output :exports none
<<iterative-higher-order-product>>
(define (identity x) x)
(define (inc x) (+ x 1))
(define (factorial num)
  (product identity 1 inc num))

(display (factorial 4)) (newline)
(display (factorial 10)) (newline)
#+end_src

#+RESULTS:
: 24
: 3628800

** Exercise 1.32

#+ATTR_LATEX: :options [a.]
a. Show that ~sum~ and ~product~ ([[*Exercise 1.31][Exercise 1.31]]) are both special cases of a still more general notion called ~accumulate~ that combines a collection of terms, using some general accumulation function:

   #+begin_src scheme
(accumulate combiner null-value term a next b)
   #+end_src

   ~accumulate~ takes as arguments the same term and range specifications as ~sum~ and ~product~, together with a ~combiner~ procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a ~null-value~ that specifies what base value to use when the terms run out. Write ~accumulate~ and show how ~sum~ and ~product~ can both be defined as simple calls to ~accumulate~.

b. If your ~accumulate~ procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.

*** Solution

**** Implementing recursive ~accumulate~

#+name: recursive-accumulate
#+begin_src scheme
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))
#+end_src

**** Implementing ~sum~ and ~product~ in terms of ~accumulate~

#+name: accumulate-sum
#+begin_src scheme :exports none
(define (sum term a next b)
  (accumulate + 0 term a next b))
#+end_src

#+name: test-accumulate-sum
#+begin_src scheme :noweb yes :results output :exports none
<<recursive-accumulate>>
<<accumulate-sum>>
(define (inc n) (+ n 1))
(define (identity x) x)
(define (sum-integers a b)
  (sum identity a inc b))

(display (sum-integers 1 10))
#+end_src

#+RESULTS: test-accumulate-sum
: 55

#+name: accumulate-product
#+begin_src scheme :exports none
(define (product term a next b)
  (accumulate * 1 term a next b))
#+end_src

#+name: test-accumulate-product
#+begin_src scheme :noweb yes :results output :exports none
<<recursive-accumulate>>
<<accumulate-product>>
(define (identity x) x)
(define (inc x) (+ x 1))
(define (factorial num)
  (product identity 1 inc num))

(display (factorial 4)) (newline)
(display (factorial 10)) (newline)
#+end_src

#+RESULTS: test-accumulate-product
: 24
: 3628800

**** Implementing iterative ~accumulate~

#+name: iterative-accumulate
#+begin_src scheme :exports none
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner (term a) result))))
  (iter a null-value))
#+end_src

#+name: test-iterative-accumulate
#+begin_src scheme :noweb yes :results output :exports none
<<iterative-accumulate>>
(define (product term a next b)
  (accumulate * 1 term a next b))
(define (inc n) (+ n 1))
(define (identify n) n)
(define (factorial num)
  (product identify 1 inc num))

(display (factorial 4)) (newline)
(display (factorial 10)) (newline)
#+end_src

#+RESULTS: test-iterative-accumulate
: 24
: 3628800

** Exercise 1.33

You can obtain an even more general version of ~accumulate~ ([[*Exercise 1.32][Exercise 1.32]]) by introducing the notion of a /filter/ on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting ~filtered-accumulate~ abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write ~filtered-accumulate~ as a procedure. Show how to express the following using ~filtered-accumulate~:

#+ATTR_LATEX: :options [a.]
a. the sum of the squares of the prime numbers in the interval /a/ to /b/ (assuming that you have a ~prime?~ predicate already written)
b. the product of all the positive integers less than /n/ that are relatively prime to /n/ (i.e., all positive integers \(i < n\) such that \(\mathrm{GCD}(i,n)=1\)).

*** Solution

**** Implementing ~filtered-accumulate~

#+name: filtered-accumulate
#+begin_src scheme
(define (filtered-accumulate predicate? combiner null-value term a next b)
  (if (> a b)
      nul-value
      (combiner
       (if (predicate? a) (term a) null-value)
       (filtered-accumulate predicate? combiner null-value term (next a) next b))))
#+end_src

**** Sum of the squares of the prime numbers in the interval a to b

#+name: sum-of-squares-prime
#+begin_src scheme
(define (inc n) (+ n 1))
(define (sum-of-squares-prime a b)
  (filtered-accumulate prime? + 0 square a inc b))
#+end_src

**** Product of all the positive integers less than n that are relatively prime to n

#+name: relative-prime
#+begin_src scheme
(define (relative-prime? i n)
  (= (gcd i n) 1))
#+end_src

#+name: product-of-relative-prime
#+begin_src scheme
(define (product-of-relative-prime n)
  (filtered-accumulate relative-prime? * 1 identity 1 inc n))
#+end_src

** Exercise 1.34

Suppose we define the procedure

#+begin_src scheme
(define (f g) (g 2))
#+end_src

Then we have

#+begin_src scheme
(f square)
4
(f (lambda (z) (* z (+ z 1))))
6
#+end_src

What happens if we (perversely) ask the interpreter to evaluate the combination ~(f f)~? Explain.

*** Solution

The trace of the evaluation of ~(f f)~ will be:

#+begin_src scheme
(f f)
(f 2)
(2 2)
#+end_src

And will fail, since ~2~ is not an function that can be applied.

** Exercise 1.35

Show that the golden ration \(\varphi\) ([[file:examples.org::#seciton-1.2.2][Section 1.2.2]]) is a fixed point of the transformation \(x \mapsto 1+1/x\), and use this fact to compute \(\varphi\) by means of the ~fixed-point~ procedure.

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: fixed-point
#+begin_src scheme :exports none
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
#+end_src

#+name: golden-ratio
#+begin_src scheme
<<fixed-point>>
(displayln (fixed-point (lambda (x) (+ 1 (/ 1 x)))
             1.0))
#+end_src

#+RESULTS: golden-ratio
: 1.6180327868852458

** Exercise 1.36

Modify ~fixed-point~ so that it prints the sequence of approximations it generates, using the ~newline~ and ~display~ primitives shown in [[*Exercise 1.22][Exercise 1.22]]. Then find a solution to \(x^x=1000\) by finding a fixed point of \(x\mapsto\log(1000)/\log(x)\). (Use Scheme's primitive ~log~ procedure, which computes natural logarithms.) Compare the number of steps this takes with and without average damping. (Note that you cannot start ~fixed-point~ with a guess of 1, as this would cause division by \(\log(1)=0\).)

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: modified-fixed-point
#+begin_src scheme :exports none
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (display next)
      (newline)
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
#+end_src

#+name: without-average-damping
#+begin_src scheme
<<modified-fixed-point>>
(displayln (fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0))
#+end_src

#+RESULTS: without-average-damping
#+begin_example
9.965784284662087
3.004472209841214
6.279195757507157
3.759850702401539
5.215843784925895
4.182207192401397
4.8277650983445906
4.387593384662677
4.671250085763899
4.481403616895052
4.6053657460929
4.5230849678718865
4.577114682047341
4.541382480151454
4.564903245230833
4.549372679303342
4.559606491913287
4.552853875788271
4.557305529748263
4.554369064436181
4.556305311532999
4.555028263573554
4.555870396702851
4.555315001192079
4.5556812635433275
4.555439715736846
4.555599009998291
4.555493957531389
4.555563237292884
4.555517548417651
4.555547679306398
4.555527808516254
4.555540912917957
4.555532270803653
4.555532270803653
#+end_example

#+name: with-average-damping
#+begin_src scheme
<<modified-fixed-point>>
(displayln (fixed-point (lambda (x) (/ (+ x (/ (log 1000) (log x))) 2.0)) 2.0))
#+end_src

#+RESULTS: with-average-damping
#+begin_example
5.9828921423310435
4.922168721308343
4.628224318195455
4.568346513136242
4.5577305909237005
4.555909809045131
4.555599411610624
4.5555465521473675
4.555537551999825
4.555537551999825
#+end_example

It takes 35 steps to converge without damping, bug only 10 steps with the damping method. It is clear that damping makes the convergence faster in this case.

** Exercise 1.37

#+ATTR_LATEX: :options [a.]
a. An infinite /continued fraction/ is an expression of the form

   \[f=\cfrac{N_1}{D_1+\cfrac{N_2}{D_2+\cfrac{N_3}{D_3+\dots}}}.\]

   As an example, one can show that the infinite continued fraction expansion with the /N_{i}/ and the /D_{i}/ all equal to 1 produces \(1/\varphi\), where \(\varphi\) is the golden ratio (described in [[file:examples.org::#section-1.2.2][Section 1.2.2]]). One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms, Such a truncation--a so-called /k-term finite continued fraction/--has the form

   \[\cfrac{N_1}{D_1+\cfrac{N_2}{\ddots+\cfrac{N_k}{D_k}}}.\]

   Suppose that ~n~ and ~d~ are procedures of one argument (the term index /i/) that return the /N_{i}/ and /D_{i}/ of the terms of the continued fraction. Define a procedure ~cont-frac~ such that evaluating ~(cont-frac n d k)~ computes the value of the /k/-term finite continued fraction. Check your procedure by approximating \(1/\varphi\) using

   #+begin_src scheme
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
   #+end_src

   for successive values of ~k~. How large must you make ~k~ in order to get an approximation that is accurate to 4 decimal places?

b. If your ~cont-frac~ procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

**** Iterative process continued fraction

#+name: k-term-finite-continued-fraction-iterative
#+begin_src scheme :exports none
(define (cont-frac n d k)
  (define (iter result i)
    (if (= i 0)
        result
        (iter (/ (n i) (+ (d i) result)) (- i 1))))
  (iter (/ (n k) (d k)) (- k 1)))
#+end_src

#+begin_src scheme :wrap table
<<k-term-finite-continued-fraction-iterative>>
(displayln (format "| ~a | ~a |\n|---+--------|" "k" "result"))
(define (test a b)
  (cond ((< a b)
         ((displayln (format
                      "| ~a | ~a |"
                      a
                      (cont-frac (lambda (i) 1.0)
                                 (lambda (i) 1.0)
                                 a)))
          (test (+ a 1) b)))))
(test 4 13)
#+end_src

#+begin_table
|  k |             result |
|----+--------------------|
|  4 | 0.6000000000000001 |
|  5 |              0.625 |
|  6 | 0.6153846153846154 |
|  7 | 0.6190476190476191 |
|  8 | 0.6176470588235294 |
|  9 | 0.6181818181818182 |
| 10 | 0.6179775280898876 |
| 11 | 0.6180555555555556 |
| 12 | 0.6180257510729613 |
#+end_table

Since \(1/\varphi=0.6180339887\dots\), ~k~ must be at least 11 in order to get an approximation that is accurate to 4 decimal places.

**** Recursive process continued fraction

#+name: k-term-finite-continued-fraction-recursive
#+begin_src scheme
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (recur (+ 1 i))))))
  (recur 1))
#+end_src

** Exercise 1.38

In 1737, the Swiss mathematician Leonhard Euler published a memoir /De Fractionibus Continuis/, which included a continued fraction expansion for \(e - 2\), where \(e\) is the base of the natural logarithms. In this fraction, the /N_{i}/ are all 1, and the /D_{i}/ are successively \(1,\,2,\,1,\,1,\,4,\,1,\,1,\,6,\,1,\,1,\,8,\, \dots\). Write a program that uses your ~cont-frac~ procedure from [[*Exercise 1.37][Exercise 1.37]] to approximate \(e\), based on Euler's expansion.

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: approximate-e
#+begin_src scheme :exports none
(define (d i)
  (if (= (modulo i 3) 2)
      (* 2 (/ (+ i 1) 3.0))
      1.0))
(define (appr-e k)
  (cont-frac (lambda (i) 1.0) d k))
#+end_src

#+name: solution1.38
#+begin_src scheme
<<k-term-finite-continued-fraction-iterative>>
<<approximate-e>>
(displayln (appr-e 10))
#+end_src

#+RESULTS: solution1.38
: 0.7182817182817183

** Exercise 1.39

A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:

\[\tan x=\cfrac{x}{1-\cfrac{x^2}{3-\cfrac{x^2}{5-\dots}}},\]

where /x/ is in radians. Define a procedure ~(tan-cf x k)~ that computes an approximation to the tangent function based on Lambert's formula. ~k~ specifies the number of terms to compute, as in [[*Exercise 1.37][Exercise 1.37]].

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: tangent-lambert-formula
#+begin_src scheme :exports none
(define (tan-cf x k)
  (cont-frac (lambda (i) (if (= i 1) x (* x x -1)))
             (lambda (i) (- (* 2.0 i) 1))
             k))
#+end_src

#+name: solution1.39
#+begin_src scheme
<<k-term-finite-continued-fraction-iterative>>
<<tangent-lambert-formula>>
(displayln (tan-cf 1 10))
(displayln (tan 1))
#+end_src

#+RESULTS: solution1.39
: 1.557407724654902
: 1.5574077246549023

** Exercise 1.40

Define a procedure ~cubic~ that can be used together with the ~newtons-method~ procedure in expressions of the form

#+begin_src scheme
(newtons-method (cubic a b c) 1)
#+end_src

to approximate zeros of the cubic \(x^3+ax^2+bx+c\).

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: newtons-method
#+begin_src scheme :exports none
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

(define dx 0.00001)

(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
#+end_src

#+name: cubic-definition
#+begin_src scheme :exports none
(define (cubic a b c)
  (lambda (x) (+ (* x x x) (* a (* x x)) (* b x) c)))
#+end_src

#+name: solution1.40
#+begin_src scheme
<<modified-fixed-point>>
<<newtons-method>>
<<cubic-definition>>

(define a 1)
(define b 1)
(define c 1)
(displayln (newtons-method (cubic a b c) 1))
#+end_src

#+RESULTS: solution1.40
: 0.33333777776275186
: -0.40739341574970156
: -1.4188731238603447
: -1.1184919351394478
: -1.0124818785025846
: -1.000153742427375
: -1.000000022096024
: -0.9999999999997796
: -0.9999999999997796

** Exercise 1.41

Define a procedure ~double~ that takes a procedure of one argument as argument and returns a procedure that applies the original procedure twice. For example, if ~inc~ is a procedure that adds 1 to its argument, then ~(double inc)~ should be a procedure that adds 2. What value is returned by

#+begin_src scheme
(((double (double double)) inc) 5)
#+end_src

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: double
#+begin_src scheme :exports none
(define (double f)
  (lambda (x) (f (f x))))
#+end_src

#+name: solution1.41
#+begin_src scheme
<<double>>
(define (inc x) (+ x 1))
(displayln (((double (double double)) inc) 5))
#+end_src

#+RESULTS: solution1.41
: 21

#+name: double-example-code-expansion
#+begin_src scheme
((double f) x) -> (f (f x))
(((double double) f) x) -> ((double (double f)) x)
(((double (double double)) f) x) -> (((double double) ((double double) f)) x)
                                 -> (((double double) (double (double f))) x)
                                 -> ((double (double (double (double f)))) x)
#+end_src

** Exercise 1.42

Let /f/ and /g/ be two one-argument functions. The /composition f/ after /g/ is defined to be the funciton \(x\mapsto f(g(x))\). Define a procedure ~compose~ that implements composition. For example, if ~inc~ is a procedure that adds 1 to its argument,

#+begin_src scheme
((compose square inc) 6)
49
#+end_src

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: compose-two-functions
#+begin_src scheme :exports none
(define (compose f g)
  (lambda (x) (f (g x))))
#+end_src

#+begin_src scheme
<<compose-two-functions>>
(define (square x) (* x x))
(define (inc x) (+ x 1))
(displayln ((compose square inc) 6))
#+end_src

#+RESULTS:
: 49

** Exercise 1.43

If /f/ is a numerical function and /n/ is a positive integer, then we can form the \(n^{\mathrm{th}}\) repeated application of /f/, which is defined to be the function whose value at /x/ is \(f(f(\dots(f(x))\dots))\). For example, if /f/ is the function \(x\mapsto x+1\), then the \(n^{\mathrm{th}}\) repeated application of /f/ is the function \(x\mapsto x+n\). If /f/ is the operation of squaring a number, then the \(n^{\mathrm{th}}\) repeated application of /f/ is the function that raises its argument to the 2^{/n/}-th power. Write a procedure that takes as inputs a procedure that computes /f/ and a positive integer /n/ and returns the procedure that computes the \(n^{\mathrm{th}}\) repeated application of /f/. Your procedure should be able to be used as follows:

#+begin_src scheme
((repeated square 2) 5)
625
#+end_src

Hint: You may find it convenient to use ~compose~ from [[*Exercise 1.42][Exercise 1.42]].

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: repeated-application
#+begin_src scheme :exports none
(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))
#+end_src

#+begin_src scheme
<<compose-two-functions>>
<<repeated-application>>
(define (square x) (* x x))
(displayln ((repeated square 2) 5))
#+end_src

#+RESULTS:
: 625

** Exercise 1.44

The idea of /smoothing/ a function is an important concept in signal processing. If /f/ is a function and /dx/ is some small number, then the smoothed version of /f/ is the function whose value at a point /x/ is the average of \(f(x-dx)\), \(f(x)\), and \(f(x+dx)\). Write a procedure ~smooth~ that takes as input a procedure that computes /f/ and returns a procedure that computes /f/ and returns a procedure that computes the smoothed /f/. It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtain the /n-fold smoothed function/. Show how to generate the /n/-fold smoothed function of any given function using ~smooth~ and ~repeated~ from [[*Exercise 1.43][Exercise 1.43]].

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: smooth-procedure
#+begin_src scheme
(define dx 0.00001)
(define (smooth f)
  (lambda (x)
    (/ (+ (f (- x dx))
          (f x)
          (f (+ x dx)))
       3.0)))
#+end_src

#+name: n-fold-smoothed-function
#+begin_src scheme
(define (smooth-nth f n)
  (repeated smooth n) f)
#+end_src

** Exercise 1.45

We saw in [[file:examples.org::#section-1.3.3][Section 1.3.3]] that attempting to compute square roots by naively finding a fixed point of \(y\mapsto x/y\) does not converge, and that this can be fixed by average damping. The same method works for finding cube roots as fixed points of the average-damped \(y\mapsto x/y^2\). Unfortunately, the process does not work for fourth roots--a single average damp is not enough to make a fixed-point search for \(y\mapsto x/y^3\) converge. On the other hand, if we average damp twice (i.e., use the average damp of the average damp of \(y\mapsto x/y^3\)) the fixed-point search does converge. Do some experiments to determine how many average damps are required to compute \(n^{\mathrm{th}}\) roots as a fixed-point search based upon repeated average damping of \(y\mapsto x/y^{n-1}\). Use this to implement a simple procedure for computing \(n^{\mathrm{th}}\) roots using ~fixed-point~, ~average-damp~, and the ~repeated~ procedure of [[*Exercise 1.43][Exercise 1.43]]. Assume that any arithmetic operations you need are available as primitives.

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: nth-root-damped
#+begin_src scheme :exports none
(define (power base n)
  (if (= n 0)
      1
      ((repeated (lambda (x) (* base x)) n) 1)))
(define (nth-root-damped x nth damp)
  (fixed-point
   ((repeated average-damp damp)
    (lambda (y)
      (/ x (power y (- nth 1)))))
   1.0))
#+end_src

| nth          | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | ... | 31 | 32 | ... | 63 | 64 |
| minimal damp | 1 | 1 | 2 | 2 | 2 | 2 | 3 | 3 |  3 |  3 |  3 |  3 |  3 |  3 |  4 |   4 |  4 |  5 |   5 |  5 |  6 |

#+name: solution1.45
#+begin_src scheme
<<fixed-point>>
<<compose-two-functions>>
<<repeated-application>>
<<nth-root-damped>>
(define (average-damp f)
  (lambda (x) ((lambda (a b) (/ (+ a b) 2.0)) x (f x))))
(define (nth-root x nth)
  (fixed-point
   ((repeated average-damp (floor (log nth 2)))
    (lambda (y) (/ x (power y (- nth 1)))))
   1.0))

(displayln (nth-root 2 258))
#+end_src

#+RESULTS: solution1.45
: 1.0026902132630033

** Exercise 1.46

Serveral of the numerical methods described in this chapter are instances of an extremely general computational strategy known as /iterative improvement/. Iterative improvement says that, to compute something, we start with an inital guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a procedure ~iterative-improve~ that takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess. ~iterative-improve~ should return as its value a procedure that takes a guess as argument and keeps improving the guess until it is good enough. Rewrite the ~sqrt~ procedure of [[file:examples.org::#section-1.1.7][Section 1.1.7]] and the ~fixed-point~ procedure of [[file:examples.org::#section-1.3.3][Section 1.3.3]] in terms of ~iterative-improve~.

*** Solution
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

#+name: iterative-improvement
#+begin_src scheme :exports none
(define (iterative-improve good-enough? improve)
  (define (iter guess)
    (if (good-enough? guess)
        guess
        (iter (improve guess))))
  (lambda (x) (iter x)))
#+end_src

#+name: iterative-improve-sqrt
#+begin_src scheme
<<iterative-improvement>>
(define (square n) (* n n))
(define (average a b) (/ (+ a b) 2.0))
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  ((iterative-improve good-enough? improve) 1.0))

(displayln (sqrt 256))
#+end_src

#+RESULTS: iterative-improve-sqrt
: 16.00000352670594

#+name: iterative-improve-fixed-point
#+begin_src scheme :exports none
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? guess)
    (< (abs (- guess (f guess)))
       tolerance))
  ((iterative-improve close-enough? f) 1.0))
#+end_src

#+name: solution1.46
#+begin_src scheme
<<iterative-improvement>>
<<iterative-improve-fixed-point>>

(define (average a b) (/ (+ a b) 2.0))
(define (average-damp f)
  (lambda (x) (average x (f x))))
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))

(displayln (fixed-point cos 1.0))
(displayln (sqrt 256))
#+end_src

#+RESULTS: solution1.46
: 0.7390893414033927
: 16.00000352670594

