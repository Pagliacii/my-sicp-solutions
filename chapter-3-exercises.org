#+title:     Exercises in SICP Chapter 3
#+author:    Jason Huang
#+email:     huangmianrui0310@outlook.com
#+date:      <2021-04-08 Thu>

#+description:  Exercises and solutions in SICP chapter 3
#+keywords:     sicp, exercises, solutions, lisp, scheme
#+language:     en
#+startup:      content
#+exclude_tags: noexport

* Chapter 3 Modularity, Objects and State
:PROPERTIES:
:header-args:scheme: :noweb yes :results output
:END:

** Footnotes :noexport:

[fn:8] $\textrm{MIT}$ Scheme provides such a procedure. If ~random~ is given an exact integer (as in Section 1.2.6) it returns an exact integer, but if it is given a decimal value (as in this exercise) it returns a decimal value.

[fn:14] The environment model will not clarify our claim in Section 1.2.1 that the interpreter can execute a procedure such as ~fact-iter~ in a constant amount of space using tail recursion. We will discuss tail recursion when we deal with the control structure of the interpreter in Section 5.4.

[fn:23] Be careful not to make the interpreter try to print a structure that contains cycles. (See [[*Exercise 3.13][Exercise 3.13]].)

[fn:33] The expression-oriented format is convenient because it avoids the need to name the intermediate expressions in a computation. Our original formulation of the constraint language is cumbersome in the same way that many languages are cumbersome when dealing with operations on compound data. For example, if we wanted to compute the product $(a+b)\cdot(c+d)$, where the variables represent vectors, we could work in "imperative style," using procedures that set the values of designated vector arguments but do not themselves return vectors as values:

#+begin_src
(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
#+end_src

Alternatively, we could deal with expressions, using procedures that return vectors as values, and thus avoid explicitly mentioning ~temp1~ and ~temp2~:

#+begin_src
(define answer (v-prod (v-sum a b) (v-sum c d)))
#+end_src

Since Lisp allows us to return compound objects as values of procedures, we can transform our imperative-style constraint language into an expression-oriented style as shown in this exercise. In languages that are impoverished in handling compound objects, such as Algol, Basic, and Pascal (unless one explicitly uses Pascal pointer variables), one is usually stuck with the imperative style when manipulating compound objects. Given the advantage of the expression-oriented format, one might ask if there is any reason to have implemented the system in imperative style, as we did in this section. One reason is that the non-expression-oriented constraint language provides a handle on constraint objects (e.g., the value of the ~adder~ procedure) as well as on connector objects. This is useful if we wish to extend the system with new operations that communicate with constraints directly rather than only indirectly via operations on connectors. Although it is easy to implement the expression-oriented style in terms of the imperative implementation, it is very difficult to do the converse.

[fn:59] Exercises such as [[*Exercise 3.51][Exercise 3.51]] and [[*Exercise 3.52][Exercise 3.52]] are valuable for testing our understanding of how ~delay~ works. On the other hand, intermixing delayed evaluation with printing--and, even worse, with assignment--is extremely confusing, and instructors of courses on computer languages have traditionally tormented their students with examination questions such as the ones in this section. Needless to say, writing programs that depend on such subtleties is odious programming style. Part of the power of stream processing is that it lets us ignore the order in which events actually happen in our programs. Unfortunately, this is precisely what we cannot afford to do in the presence of assignment, which forces us to be concerned with time and change.

[fn:64] This exercise shows how call-by-need is closely related to ordinary memoization as described in [[*Exercise 3.27][Exercise 3.27]]. In that exercise, we used assignment to explicitly construct a local table. Our call-by-need stream optimization effectively constructs such a table automatically, storing values in the previously forced parts of the stream.

[fn:69] We will require that the weighting function be such that the weight of a pair increases as we move out along a row or down along a column of the array of pairs.

[fn:70] To quote from G. H. Hardy's obituary of Ramanujan (Hardy 1921): "It was Mr. Littlewood (I believe) who remarked that 'every positive integer was one of his friends.' I remember once going to see him when he was lying ill at Putney. I had ridden in taxicab No. 1729, and remarked that the number seemed to me a rather dull one, and that I hoped it was not an unfavorable omen. 'No,' he replied, 'it is a very interesting number; it is the smallest number expressible as the sum of two cubes in two different ways.'" The trick of using weighted pairs to generate the Ramanujan numbers was shown to us by Charles Leiserson.

** Exercise 3.1

An /accumulator/ is a procedure that is called repeatedly with a single numeric argument and accumulates its arguments into a sum. Each time it is called, it returns the currently accumulated sum. Write a procedure ~make-accumulator~ that generates accumulators, each maintaining an independent sum. The input to ~make-accumulator~ should specify the initial value of the sum; for example

#+begin_src scheme
(define A (make-accumulator 5))
(A 10)
15
(A 10)
25
#+end_src

*** Solution

#+name: make-accumulator-procedure
#+begin_src scheme
(define (make-accumulator acc)
  (lambda (num)
    (set! acc (+ acc num))
    acc))
#+end_src

#+name: test-solution-3-1
#+begin_src scheme
<<make-accumulator-procedure>>

(define A (make-accumulator 5))
(display (A 10)) (newline)
(display (A 10)) (newline)
#+end_src

#+RESULTS: test-solution-3-1
: 15
: 25

** Exercise 3.2

In software-testing applications, it is useful to be able to count the number of times a given procedure is called during the course of a computation. Write a procedure ~make-monitored~ that takes as input a procedure, ~f~, that itself takes one input. The result returned by ~make-monitored~ is a third procedure, say ~mf~, that keeps track of the number of times it has been called by maintaining an internal counter. If the input to ~mf~ is the special symbol ~how-many-calls?~, then ~mf~ returns the value of the counter. If the input is the special symbol ~reset-count~, then ~mf~ resets the counter to zero. For any other input, ~mf~ returns the result of calling ~f~ on that input and increments the counter. For instance, we could make a monitored version of the ~sqrt~ procedure:

#+begin_src scheme
(define s (make-monitored sqrt))
(s 100)
10
(s 'how-many-calls?)
1
#+end_src

*** Solution

#+name: make-monitored-procedure
#+begin_src scheme
(define (make-monitored f)
  (let ((count 0))
    (define (mf . args)
      (if (= (length args) 1)
          (let ((arg (car args)))
            (cond ((eq? arg 'how-many-calls?) count)
                  ((eq? arg 'reset-count) (set! count 0))
                  (else (set! count (+ count 1))
                        (f arg))))
          (error "bad arguments: " args)))
    mf))
#+end_src

#+name: test-solution-3-2
#+begin_src scheme
<<make-monitored-procedure>>

(define s (make-monitored sqrt))
(display (s 100)) (newline)
(display (s 'how-many-calls?)) (newline)
(display (s 'reset-count)) (newline)
(display (s 'how-many-calls?)) (newline)
#+end_src

#+RESULTS: test-solution-3-2
: 10
: 1
: #<void>
: 0

** Exercise 3.3

Modify the ~make-account~ procedure so that it creates password-protected accounts. That is, ~make-account~ should take a symbol as an additional argument, as in

#+begin_src scheme
(define acc (make-account 100 'secret-password))
#+end_src

The resulting account object should process a request only if it is accompanied by the password with which the account was created, and should otherwise return a complaint:

#+begin_src scheme
((acc 'secret-password 'withdraw) 40)
60
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
#+end_src

*** Solution

#+name: password-protected-account-procedure
#+begin_src scheme
(define (make-account balance secret)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request: MAKE-ACCOUNT"
                       m))))
  (define (warning n) "Incorrect password")
  (lambda (password message)
    (if (eq? password secret) (dispatch message) warning)))
#+end_src

#+name: test-solution-3-3
#+begin_src scheme
<<password-protected-account-procedure>>

(define acc (make-account 100 'secret-password))
(display ((acc 'secret-password 'withdraw) 40)) (newline)
(display ((acc 'some-other-password 'deposit) 50))
#+end_src

#+RESULTS: test-solution-3-3
: 60
: Incorrect password

** Exercise 3.4

Modify the ~make-account~ procedure of [[*Exercise 3.3][Exercise 3.3]] by adding another local state variable so that, if an account is accessed more than seven consecutive times with an incorrect password, it invokes the procedure ~call-the-cops~.

*** Solution

#+name: make-account-procedure-counting-incorrect-password
#+begin_src scheme
(define (make-account balance secret)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request: MAKE-ACCOUNT"
                       m))))
  (define (warning n) "Incorrect password")
  (define (call-the-cops n) "You're wanted!!!")
  (let ((incorrect 0))
    (lambda (password message)
      (cond ((eq? password secret)
             (set! incorrect 0) (dispatch message))
            ((< incorrect 7)
             (set! incorrect (+ incorrect 1)) warning)
            (else call-the-cops)))))
#+end_src

#+name: test-solution-3-4
#+begin_src scheme
<<make-account-procedure-counting-incorrect-password>>

(define acc (make-account 100 'secret-password))
(printf "~a~n" ((acc 'wrong-password-1 'withdraw) 10))
(printf "~a~n" ((acc 'wrong-password-2 'withdraw) 10))
(printf "~a~n" ((acc 'wrong-password-3 'withdraw) 10))
(printf "~a~n" ((acc 'wrong-password-4 'withdraw) 10))
(printf "~a~n" ((acc 'wrong-password-5 'withdraw) 10))
(printf "~a~n" ((acc 'wrong-password-6 'withdraw) 10))
(printf "~a~n" ((acc 'wrong-password-7 'withdraw) 10))
(printf "~a~n" ((acc 'wrong-password-8 'withdraw) 10))
#+end_src

#+RESULTS: test-solution-3-4
: Incorrect password
: Incorrect password
: Incorrect password
: Incorrect password
: Incorrect password
: Incorrect password
: Incorrect password
: You're wanted!!!

** Exercise 3.5

/Monte Carlo integration/ is a method of estimating define integrals by means of Monte Carlo simulation. Consider computing the area of a region of space described by a predicate $P(x,y)$ that is true for points $(x,y)$ in the region and false for points not in the region. For example, the region contained within a circle of radius 3 centered at $(5,7)$ is described by the predicate that tests whether $(x-5)^2+(y-7)^2\le3^2$. To estimate the area of the region described by such a predicate, begin by choosing a rectangle that contains the region. For example, a rectangle with diagonally opposite corners at $(2,4)$ and $(8,10)$ contains the circle above. The desired integral is the area of that portion of the rectangle that lies in the region. We can estimate the integral by picking, at random, points $(x,y)$ that lie in the rectangle, and testing $P(x,y)$ for each point to determine whether the point lies in the region. If we try this with many points, then the fraction of points that fall in the region should give an estimate of the proportion of the rectangle that lies in the region. Hence, multiplying this fraction by the area of the entire rectangle should produce an estimate of the integral.

Implement Monte Carlo integration as a procedure ~estimate-integral~ that takes as arguments a predicate ~P~, upper and lower bounds ~x1~, ~x2~, ~y1~, and ~y2~ for the rectangle, and the number of trials to perform in order to produce the estimate. Your procedure should use the same ~monte-carlo~ procedure that was used above to estimate $\pi$. Use your ~estimate-integral~ to produce and estimate of $\pi$ by measuring the area of a unit circle.

You will find it useful to have a procedure that returns a number chosen at random from a given range. The following ~random-in-range~ procedure implements this in terms of the ~random~ procedure used in Section 1.2.6, which returns a nonnegative number less than its input.[fn:8]

#+name: random-in-range-procedure
#+begin_src scheme
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (* (random) range))))
#+end_src

*** Solution

#+name: monte-carlo-procedure
#+begin_src scheme
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1)
                 (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1)
                 trials-passed))))
  (iter trials 0))
#+end_src

#+name: estimate-integral-procedure
#+begin_src scheme
(define (estimate-integral P x1 x2 y1 y2 trials)
  (define (experiment) (P (random-in-range x1 x2) (random-in-range y1 y2)))
  (monte-carlo trials experiment))
#+end_src

#+name: test-solution-3-5
#+begin_src scheme
<<monte-carlo-procedure>>
<<random-in-range-procedure>>
<<estimate-integral-procedure>>

(define (in-circle-predicate cx cy radius)
  (lambda (x y)
    (<= (+ (expt (- x cx) 2)
           (expt (- y cy) 2))
        (expt radius 2))))
(define P (in-circle-predicate 5.0 7.0 3.0))
(define in-unit-circle (in-circle-predicate 0.0 0.0 1.0))
(display (* (estimate-integral P 2.0 8.0 4.0 10.0 10000) 36.0)) (newline)
(display (* (estimate-integral in-unit-circle -1.0 1.0 -1.0 1.0 10000) 4.0))
#+end_src

#+RESULTS: test-solution-3-5
: 28.5228
: 3.1584

** Exercise 3.6

It is useful to be able to reset a random-number generator to produce a sequence starting from a given value. Design a new ~rand~ procedure that is called with an argument that is either the symbol ~generate~ or the symbol ~reset~ and behaves as follows: ~(rand 'generate)~ produces a new random number; ~((rand 'reset) <new-value>)~ resets the internal state variable to the designated $\langle\emph{new-value}\rangle$. Thus, by resetting the state, one can generate repeatable sequences. These are very handy to have when testing and debugging programs that use random numbers.

*** Solution

#+name: rand-procedure-with-reset
#+begin_src scheme
(define (rand-update x)
  ;; ref: https://en.wikipedia.org/wiki/Linear_congruential_generator
  (let ((a 1103515245)
        (b 12345)
        (m (expt 2 31)))
    (modulo (+ (* a x) b) m)))
(define random-init (rand-update 65536))
(define rand
  (let ((seed random-init))
    (lambda (m)
      (cond ((eq? m 'generate)
             (set! seed (rand-update seed)) seed)
            ((eq? m 'reset)
             (lambda (new-seed) (set! seed (rand-update new-seed))))
            (else (error "Unknown request: RAND" m))))))
#+end_src

#+name: test-solution-3-6
#+begin_src scheme
<<rand-procedure-with-reset>>

(display (rand 'generate)) (newline)
(display (rand 'generate)) (newline)
((rand 'reset) 65536)
(display (rand 'generate)) (newline)
(display (rand 'generate)) (newline)
#+end_src

#+RESULTS: test-solution-3-6
: 1850021502
: 1673078751
: 1850021502
: 1673078751

** Exercise 3.7

Consider the bank account objects created by ~make-account~, with the password modification described in [[*Exercise 3.3][Exercise 3.3]]. Suppose that our banking system requires the ability to make joint accounts. Define a procedure ~make-joint~ that accomplishes this. ~make-joint~ should take three arguments. The first is a password-protected account. The second argument must match the password with which the account was defined in order for the ~make-joint~ operation to proceed. The third argument is a new password. ~make-joint~ is to create an additional access to the original account using the new password. For example, if ~peter-acc~ is a bank account with password ~open-sesame~, then

#+begin_src scheme
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosehub))
#+end_src

will allow one to make transactions on ~peter-acc~ using the name ~paul-acc~ and the password ~rosehub~. You may wish to modify your solution to [[*Exercise 3.3][Exercise 3.3]] to accommodate this new feature.

*** Solution

#+name: make-joint-procedure
#+begin_src scheme
(define (make-joint account orig-pwd joint-pwd)
  (lambda (password message)
    (if (eq? password joint-pwd)
        (account orig-pwd message)
        (error "Incorrect password"))))
#+end_src

#+name: test-solution-3-7
#+begin_src scheme
<<password-protected-account-procedure>>
<<make-joint-procedure>>

(define peter-acc (make-account 100 'open-sesame))
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosehub))
(display ((paul-acc 'rosehub 'withdraw) 10)) (newline)
(display ((peter-acc 'open-sesame 'withdraw) 0))
#+end_src

#+RESULTS: test-solution-3-7
: 90
: 90

** Exercise 3.8

When we defined the evaluation model in Section 1.1.3, we said that the first step in evaluating an expression is to evaluate its subexpressions. But we never specified the order in which the subexpressions should be evaluated (e.g., left to right or right to left). When we introduce assignment, the order in which the arguments to a procedure are evaluated can make a difference to the result. Define a simple procedure ~f~ such that evaluating

#+begin_src scheme
(+ (f 0) (f 1))
#+end_src

will return 0 if the arguments to ~+~ are evaluated from left to right but will return 1 if the arguments are evaluated from right to left.

*** Solution

#+name: f-procedure
#+begin_src scheme
(define f
  (let ((memory 1))
    (lambda (n)
      (set! memory (* memory n))
      memory)))
#+end_src

#+name: test-solution-3-8-1
#+begin_src scheme
<<f-procedure>>

(display (+ (f 0) (f 1))) (newline)
#+end_src

#+RESULTS: test-solution-3-8-1
: 0

#+name: test-solution-3-8-2
#+begin_src scheme
<<f-procedure>>

(display (+ (f 1) (f 0))) (newline)
#+end_src

#+RESULTS: test-solution-3-8-2
: 1

** Exercise 3.9

In Section 1.2.1 we used the substitution model to analyze two procedures for computing factorials, a recursive version

#+begin_src scheme
(define (factorial n)
  (if (= n 1) 1 (* n (factorial (- n 1)))))
#+end_src

and an iterative version

#+begin_src scheme
(define (factorial n) (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
#+end_src

Show the environment structures created by evaluating ~(factorial 6)~ using each version of the ~factorial~ procedure.[fn:14]

*** Solution

#+name: recursive-version-environment
#+begin_example
              parameters: n
              body: (if (= n 1) 1 (* n (factorial (- n 1))))
                         ^
                         |
                       +-+-+---+
                       | * | *-+--+
                       +---+---+  |
                           ^      |
                           |      V
              +------------+-----------------------------------------------------------------------------+
              |            |                                                                             |
global env -->| factorial:-+                                                                             |
              |                                                                                          |
              +------------------------------------------------------------------------------------------+
(factorial 6)    ^                ^                ^                ^                ^                ^
                 |                |                |                |                |                |
              +-----+          +-----+          +-----+          +-----+          +-----+          +-----+
        E1 -->| n:6 |    E2 -->| n:5 |    E3 -->| n:4 |    E4 -->| n:3 |    E5 -->| n:2 |    E6 -->| n:1 |
              +-----+          +-----+          +-----+          +-----+          +-----+          +-----+
      (* n (factorial  (* n (factorial  (* n (factorial  (* n (factorial  (* n (factorial          1
            (- n 1)))        (- n 1)))        (- n 1)))        (- n 1)))        (- n 1)))
#+end_example

#+name: iterative-version-environment
#+begin_example
              parameters: n            parameters: product counter max-count
              body: (fact-iter 1 1 n)  body: (if (> counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))
                         ^                      ^
                         |                      |
                       +-+-+---+              +-+-+---+
                       | * | *-+--+           | * | *-+--+
                       +---+---+  |           +---+---+  |
                           ^      |               ^      |
                           |      V               |      V
              +------------+----------------------+------------------------------------------------------+
              |            |                      |                                                      |
global env -->| factorial:-+           fact-iter:-+                                                      |
              |                                                                                          |
              +------------------------------------------------------------------------------------------+
(factorial 6)    ^                      ^                               ^                               ^
                 |               +-------------+                 +-------------+                 +-------------+
              +-----+            | product:  1 |                 | product:  1 |                 | product:  2 |
        E1 -->| n:6 |      E2 -->| counter:  1 |           E3 -->| counter:  2 |           E4 -->| counter:  3 |
              +-----+            | max-count:6 |                 | max-count:6 |                 | max-count:6 |
                                 +-------------+                 +-------------+                 +-------------+
      (fact-iter 1 1 n)  (fact-iter (* counter product)  (fact-iter (* counter product)  (fact-iter (* counter product)
                                    (+ counter 1)                   (+ counter 1)                   (+ counter 1)
                                    max-count))                     max-count))                     max-count))

              +-------------------------------------------------------------------------------------------------------------+
              |                                                                                                             |
global env -->| factorial              fact-iter                                                                            |
              |                                                                                                             |
              +-------------------------------------------------------------------------------------------------------------+
                     ^                               ^                               ^                               ^
              +-------------+                 +-------------+                 +-------------+                 +-------------+
              | product:  6 |                 | product: 24 |                 | product:120 |                 | product:120 |
        E5 -->| counter:  4 |           E6 -->| counter:  5 |           E7 -->| counter:  6 |           E8 -->| counter:  6 |
              | max-count:6 |                 | max-count:6 |                 | max-count:6 |                 | max-count:6 |
              +-------------+                 +-------------+                 +-------------+                 +-------------+
      (fact-iter (* counter product)  (fact-iter (* counter product)  (fact-iter (* counter product)  product
                 (+ counter 1)                   (+ counter 1)                   (+ counter 1)
                 max-count))                     max-count))                     max-count))
#+end_example

** Exercise 3.10

In the ~make-withdraw~ procedure, the local variable ~balance~ is created as a parameter of ~make-withdraw~. We could also create the local state variable explicitly, using ~let~, as follows:

#+begin_src scheme
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
#+end_src

Recall from Section 1.3.2 that ~let~ is simply syntactic sugar for a procedure call:

#+begin_src scheme
(let ((<var> <exp>)) <body>)
#+end_src

is interpreted as an alternate syntax for

#+begin_src scheme
((lambda (<var>) <body>) <exp>)
#+end_src

Use the environment model to analyze this alternate version of ~make-withdraw~, drawing figures like the ones above to illustrate the interactions

#+begin_src scheme
(define W1 (make-withdraw 100))
(W1 50)
(define W2 (make-withdraw 100))
#+end_src

Show that the two versions of ~make-withdraw~ create objects with the same behavior. How do the environment structures differ for the two versions?

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.10][sicp-ex-3.10]]
- [[https://wizardbook.wordpress.com/2010/12/14/exercise-3-10/][Exercise 3.10]]

** Exercise 3.11

In Section 3.2.3 we saw how the environment model described the behavior of procedures with local state. Now we have seen how internal definitions work. A typical message-passing procedure contains both of these aspects. Consider the bank account procedure of Section 3.1.1:

#+begin_src scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else
           (error "Unknown request: MAKE-ACCOUNT"
                  m))))
  dispatch)
#+end_src

Show the environment structure generated by the sequence of interactions

#+begin_src scheme
(define acc (make-account 50))
((acc 'deposit) 40)
90
((acc 'withdraw) 60)
30
#+end_src

Where is the local state for ~acc~ kept? Suppose we define another account

#+begin_src scheme
(define acc2 (make-account 100))
#+end_src

How are the local states for the two accounts kept distinct? Which parts of the environment structure are shared between ~acc~ and ~acc2~?

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.11][sicp-ex-3.11]]
- [[https://wizardbook.wordpress.com/2010/12/14/exercise-3-11/][Exercise 3.11]]

** Exercise 3.12

The following procedure for appending lists was introduced in Section 2.2.1:

#+begin_src scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+end_src

~append~ forms a new list by successively ~cons~​ing the elements of ~x~ onto ~y~. The procedure ~append!~ is similar to ~append~, but it is a mutator rather than a constructor. It appends the lists by splicing them together, modifying the final pair of ~x~ so that its ~cdr~ is now ~y~. (It is an error to call ~append!~ with an empty ~x~.)

#+name: append-mutator-procedure
#+begin_src scheme
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
#+end_src

Here ~last-pair~ is a procedure that returns the last pair in its argument:

#+name: last-pair-procedure
#+begin_src scheme
(define (last-pair x)
  (if (null? (cdr x)) x (last-pair (cdr x))))
#+end_src

Consider the interaction

#+begin_src scheme
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
(a b c d)
(cdr x)
<response>
(define w (append! x y))
w
(a b c d)
(cdr x)
<response>
#+end_src

What are the missing $\langle response\rangle$​s? Draw box-and-pointer diagrams to explain your answer.

*** Solution

#+name: test-solution-3-12-1
#+begin_src scheme
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
(display z) (newline)
(display (cdr x))
#+end_src

#+RESULTS: test-solution-3-12-1
: (a b c d)
: (b)

#+begin_example
    +---+---+  +---+---+        +---+---+  +---+---+
x ->| * | *-+->| * | / |    y ->| * | *-+->| * | / |
    +-+-+---+  +-+-+---+        +-+-+---+  +-+-+---+
      |          |                |          |
      V          V                V          V
    +---+      +---+            +---+      +---+
    | a |      | b |            | c |      | d |
    +---+      +---+            +---+      +---+

    +---+---+  +---+---+  +---+---+  +---+---+
z ->| * | *-+->| * | *-+->| * | *-+->| * | / |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | a |      | b |      | c |      | d |
    +---+      +---+      +---+      +---+
#+end_example

#+name: test-solution-3-12-2
#+begin_src scheme
<<append-mutator-procedure>>
<<last-pair-procedure>>
(define x (list 'a 'b))
(define y (list 'c 'd))
(define w (append! x y))
(display w) (newline)
(display (cdr x))
#+end_src

#+RESULTS: test-solution-3-12-2
: (a b c d)
: (b c d)

#+begin_example
    +---+---+  +---+---+        +---+---+  +---+---+
x ->| * | *-+->| * | / |    y ->| * | *-+->| * | / |
    +-+-+---+  +-+-+---+        +-+-+---+  +-+-+---+
      |          |                |          |
      V          V                V          V
    +---+      +---+            +---+      +---+
    | a |      | b |            | c |      | d |
    +---+      +---+            +---+      +---+

      x                     y
      |                     |
      V                     V
    +---+---+  +---+---+  +---+---+  +---+---+
w ->| * | *-+->| * | *-+->| * | *-+->| * | / |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | a |      | b |      | c |      | d |
    +---+      +---+      +---+      +---+
#+end_example

** Exercise 3.13

Consider the following ~make-cycle~ procedure, which uses the ~last-pair~ procedure defined in [[*Exercise 3.12][Exercise 3.12]]:

#+begin_src scheme
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
#+end_src

Draw a box-and-pointer diagram that shows the structure ~z~ created by

#+begin_src scheme
(define z (make-cycle (list 'a 'b 'c)))
#+end_src

What happens if we try to compute ~(last-pair z)~?

*** Solution

#+begin_example
      +------------------------------+
      |                              |
      V                              |
    +---+---+  +---+---+  +---+---+  |
z ->| * | *-+->| * | *-+->| * | *-+--+
    +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |
      V          V          V
    +---+      +---+      +---+
    | a |      | b |      | c |
    +---+      +---+      +---+
#+end_example

If we try to compute ~(last-pair z)~, it will cause an infinite loop.

** Exercise 3.14

The following procedure is quite useful, although obscure:

#+begin_src scheme
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
#+end_src

~loop~ uses the "temporary" variable ~temp~ to hold the old value of the ~cdr~ of ~x~, since the ~set-cdr!~ on the next line destroys the ~cdr~. Explain what ~mystery~ does in general. Suppose ~v~ is defined by ~(define v (list 'a 'b 'c 'd))~. Draw the box-and-pointer diagram that represents the list to which ~v~ is bound. Suppose that we new evaluate ~(define w (mystery v))~. Draw box-and-pointer diagrams that show the structures ~v~ and ~w~ after evaluating this expression. What would be printed as the values of ~v~ and ~w~?

*** Solution

~mystery~ procedure will reverse the argument.

#+begin_src scheme
v
(a)
w
(d c b a)
#+end_src

#+begin_example
    +---+---+  +---+---+  +---+---+  +---+---+
v ->| * | *-+->| * | *-+->| * | *-+->| * | / |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | a |      | b |      | c |      | d |
    +---+      +---+      +---+      +---+

----------------------------------------------
loop 1:
      x        temp
      |          |
      V          V
    +---+---+  +---+---+  +---+---+  +---+---+
v ->| * | / |  | * | *-+->| * | *-+->| * | / |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | a |      | b |      | c |      | d |
    +---+      +---+      +---+      +---+

----------------------------------------------
loop 2:
      +--------------+    temp
      |       x -+   |      |
      V          V   |      V
    +---+---+  +---+-+-+  +---+---+  +---+---+
v ->| * | / |  | * | * |  | * | *-+->| * | / |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | a |      | b |      | c |      | d |
    +---+      +---+      +---+      +---+

----------------------------------------------
loop 3:
                 +--------------+
      +----------|---+      x   |    temp
      |          |   |      |   |      |
      V          V   |      V   |      V
    +---+---+  +---+-+-+  +---+-+-+  +---+---+
v ->| * | / |  | * | * |  | * | * |  | * | / |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | a |      | b |      | c |      | d |
    +---+      +---+      +---+      +---+

----------------------------------------------
loop 4:
                            +--------------+
                 +----------|---+          |
      +----------|---+      |   |      x   |
      |          |   |      |   |      |   |
      V          V   |      V   |      V   |
    +---+---+  +---+-+-+  +---+-+-+  +---+-+-+
v ->| * | / |  | * | * |  | * | * |  | * | * |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | a |      | b |      | c |      | d |
    +---+      +---+      +---+      +---+

----------------------------------------------

                                       v
                                       |
                                       V
    +---+---+  +---+---+  +---+---+  +---+---+
w ->| * | *-+->| * | *-+->| * | *-+->| * | / |
    +-+-+---+  +-+-+---+  +-+-+---+  +-+-+---+
      |          |          |          |
      V          V          V          V
    +---+      +---+      +---+      +---+
    | d |      | c |      | b |      | a |
    +---+      +---+      +---+      +---+
#+end_example

** Exercise 3.15

Draw box-and-pointer diagrams to explain the effect of ~set-to-wow!~ on the structures ~z1~ and ~z2~ above.

*** Solution

#+begin_example
     +---+---+                  +---+---+  +---+---+  +---+---+
z1 ->| * | * |             z2 ->| * | *-+->| * | *-+->| * | / |
     +-+-+-+-+                  +-+-+---+  +-+-+---+  +-+-+---+
       |   |                      |          |          |
       v   v                      |          v          v
     +---+---+  +---+---+         |        +---+      +---+
 x ->| * | *-+->| * | / |         |        | a |      | b |
     +-+-+---+  +-+-+---+         |        +---+      +---+
       |          |               |          ^          ^
       v          v               |          |          |
     +---+      +---+             |        +-+-+---+  +-+-+---+
     | a |      | b |             +------->| * | *-+->| * | / |
     +---+      +---+                      +---+---+  +---+---+

---------------------------------------------------------------
After apply set-to-wow!

     +---+---+                  +---+---+  +---+---+  +---+---+
z1 ->| * | * |             z2 ->| * | *-+->| * | *-+->| * | / |
     +-+-+-+-+                  +-+-+---+  +-+-+---+  +-+-+---+
       |   |                      |       +--+          |
       v   v                      |       v             v
     +---+---+  +---+---+         |     +---+  +---+  +---+
 x ->| * | *-+->| * | / |         |     |wow|  | a |  | b |
     +-+-+---+  +-+-+---+         |     +---+  +---+  +---+
       |          |               |              ^      ^
       v          v               |          +---+      |
     +---+      +---+             |        +-+-+---+  +-+-+---+
     |wow|      | b |             +------->| * | *-+->| * | / |
     +---+      +---+                      +---+---+  +---+---+
#+end_example

** Exercise 3.16

Ben Bitdiddle decides to write a procedure to count the number of pairs in any list structure. "It's easy," he reasons. "The number of pairs in any structure is the number in the ~car~ plus the number in the ~cdr~ plus one more to count the current pair." So Ben writes the following procedure:

#+name: count-pairs-procedure
#+begin_src scheme
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
#+end_src

Show that this procedure is not correct. In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben's procedure would return 3; return 4; return 7; never return at all.

*** Solution

#+begin_src scheme
<<count-pairs-procedure>>
(printf "~a~n" (count-pairs '(1 (2 3))))
(printf "~a~n" (count-pairs '(1 2 3)))
(define x '(1))
(define y (cons x x))
(printf "~a~n" (count-pairs (list x x)))
(printf "~a~n" (count-pairs (cons y y)))
#+end_src

#+RESULTS:
: 4
: 3
: 4
: 7

#+begin_example
     +---+---+  +---+---+  +---+---+       +---+---+
x3 ->| * | *-+->| * | *-+->| * | / |  x7 ->| * | * |
     +-+-+---+  +-+-+---+  +-+-+---+       +-+-+-+-+
       |          |          |               |   |
       v          v          v               vv--+
     +---+      +---+      +---+           +---+---+
     | 1 |      | 2 |      | 3 |           | * | * |
     +---+      +---+      +---+           +-+-+-+-+
                                             |   |
     +---+---+  +---+---+                    vv--+
x4 ->| * | *-+->| * | / |                  +---+---+
     +-+-+---+  +-+-+---+                  | * | / |
       |          |                        +-+-+---+
       v----------+                          |
     +---+---+                               v
     | * | / |                             +---+
     +-+-+---+                             | 1 |
       |                                   +---+
       v
     +---+
     | 1 |
     +---+

       +-----------------------------+
       v                             |
     +---+---+  +---+---+  +---+---+ |
inf->| * | *-+->| * | *-+->| * | *-+-+
     +-+-+---+  +-+-+---+  +-+-+---+
       |          |          |
       v          v          v
     +---+      +---+      +---+
     | 1 |      | 2 |      | 3 |
     +---+      +---+      +---+
#+end_example

** Exercise 3.17

Devise a correct version of the ~count-pairs~ procedure of [[*Exercise 3.16][Exercise 3.16]] that returns the number of distinct pairs in any structure. (Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)

*** Solution

#+name: correct-count-pairs-procedure
#+begin_src scheme
(define count-pairs
  (let ((seen '()))
    (lambda (x)
      (cond ((not (pair? x)) 0)
            ((memq x seen) 0)
            (else (set! seen (cons x seen))
                  (+ (count-pairs (car x))
                     (count-pairs (cdr x))
                     1))))))
#+end_src

** Exercise 3.18

Write a procedure that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive ~cdr~​s would go into an infinite loop. [[*Exercise 3.13][Exercise 3.13]] constructed such lists.

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.18][sicp-ex-3.18]]
- [[https://wizardbook.wordpress.com/2010/12/16/exercise-3-18][Exercise 3.18]]

** Exercise 3.19

Redo [[*Exercise 3.18][Exercise 3.18]] using an algorithm that takes only a constant amount of space. (This requires a very clever idea.)

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.19][sicp-ex-3.19]]
- [[https://wizardbook.wordpress.com/2010/12/16/exercise-3-19/][Exercise 3.19]]

** Exercise 3.20

Draw environment diagrams to illustrate the evaluation of the sequence of expressions

#+begin_src scheme
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
17
#+end_src

using the procedural implementation of pairs given above. (Compare [[*Exercise 3.11][Exercise 3.11]].)

*** Solution

#+name: procedural-implementation-of-pairs
#+begin_src scheme
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else
           (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
(define (set-car! z new-value)
  ((z 'set-car!) new-value) z)
(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value) z)
#+end_src

#+begin_example
         +--------------------------------------------------------------------------+
         |  cons:-+        +->x:-+                    z:-+                          |
global ->|        |        |  ^--|-----------------------|------------+             |
env      |        |        +-----|-----------------------|----------+ |             |
         +--------+--------------+-----------------------+----------+-+-------------+
                  |     ^        |           ^           |          |^|
                  v     |        v           |           v          |||
              +---+---+ |    +---+---+  +----+----+  +---+---+  +---+++---+
            +-+-* | *-+-+  +-+-* | *-+->|x:1      |  | * | *-+->|x:-+ |   |
            | +---+---+    | +---+---+  |y:2      |  +-+-+---+  |y:---+   |
            | +------------+       E1 ->|set-x!:  |    |   E2 ->|set-x!:  |
            v v v---------------+       |set-y!:  |    |        |set-y!:  |
parameters: x y                 |       |dispatch:|    |        |dispatch:|
body: (define (set-x! v) ...)   |       +---------+    |        +---------+
      (define (set-y! v) ...)   +----------------------+
      (define (dispatch m) ...)
      dispatch

-------------------------------------------------------------------------------------
(set-car! (cdr z) 17)

         +--------------------------------------------------------------------------+
         |  cons:-+        +->x:-+                    z:-+                          |
global ->|        |        |  ^--|-----------------------|------------+             |
env      |        |        +-----|-----------------------|----------+ |             |
         +--------+--------------+-----------------------+----------+-+-------------+
                  |     ^        |           ^           |          |^|
                  v     |        v           |           v          |||
              +---+---+ |    +---+---+  +----+----+  +---+---+  +---+++---+
            +-+-* | *-+-+  +-+-* | *-+->|x:17     |  | * | *-+->|x:-+ |   |
            | +---+---+    | +---+---+  |y:2      |  +-+-+---+  |y:---+   |
            | +------------+       E1 ->|set-x!:  |    |   E2 ->|set-x!:  |
            v v v---------------+       |set-y!:  |    |        |set-y!:  |
parameters: x y                 |       |dispatch:|    |        |dispatch:|
body: (define (set-x! v) ...)   |       +---------+    |        +---------+
      (define (set-y! v) ...)   +----------------------+
      (define (dispatch m) ...)
      dispatch
#+end_example

** Exercise 3.21

Ben Bitdiddle decides to test the queue implementation described above. He types in the procedures to the Lisp interpreter and proceeds to try them out:

#+begin_src scheme
(define q1 (make-queue))
(insert-queue! q1 'a)
((a) a)
(insert-queue! q1 'b)
((a b) b)
(delete-queue! q1)
((b) b)
(delete-queue! q1)
(() b)
#+end_src

"It's all wrong!" he complains. "The interpreter's response shows that the last item is inserted into the queue twice. And when I delete both items, the second ~b~ is still there, so the queue isn't empty, even though it's supposed to be." Eva Lu Ator suggests that Ben has misunderstood what is happening. "It's not that the items are going into the queue twice," she explains. "It's just that the standard Lisp printer doesn't know how to make sense of the queue representation. If you want to see the queue printed correctly, you'll have to define your own print procedure for queues." Explain what Eva Lu is talking about. In particular, show why Ben's examples produce the printed results that they do. Define a procedure ~print-queue~ that takes a queue as input and prints the sequence of items in the queue.

*** Solution

#+begin_example
       +---+---+  rear-ptr
queue->| * | *-+----+
       +-+-+---+    |
front-ptr|          |
         v          v
       +---+---+  +---+---+
       | * | *-+->| * | / |
       +-+-+---+  +-+-+---+
         |          |
         v          v
       +---+      +---+
       | a |      | b |
       +---+      +---+
#+end_example

#+name: print-queue-procedure
#+begin_src scheme
(define (print-queue q)
  (printf "~a~n" (front-ptr q)))
#+end_src

** Exercise 3.22

Instead of representing a queue as a pair of pointers, we can build a queue as a procedure with local state. The local state will consist of pointers to the beginning and the end of an ordinary list. Thus, the ~make-queue~ procedure will have the form

#+begin_src scheme
(define (make-queue)
  (let ((front-ptr ... )
        (rear-ptr ... ))
    <definitions of internal procedures>
    (define (dispatch m) ...)
    dispatch))
#+end_src

Complete the definition of ~make-queue~ and provide implementations of the queue operations using this representation.

*** Solution

#+name: make-queue-procedure-with-local-state
#+begin_src scheme
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-queue?) (null? front-ptr))
    (define (set-front-ptr! item) (set! front-ptr item))
    (define (set-rear-ptr! item) (set! rear-ptr item))
    (define (front-queue)
      (if (null? front-ptr)
          (error "FRONT called with an empty queue" queue)
          (car front-ptr)))
    (define (insert-queue! item)
      (let ((new-item (list item)))
        (set-front-ptr! (append front-ptr new-item))
        (set-rear-ptr! new-item)
        dispatch))
    (define (delete-queue!)
      (if (null? front-ptr)
          (error "DELETE! called with an empty queue" queue)
          (begin (set-front-ptr! (cdr front-ptr))
                 dispatch)))
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) (empty-queue?))
            ((eq? m 'front-queue) front-queue)
            ((eq? m 'insert-queue!) insert-queue!)
            ((eq? m 'delete-queue!) (delete-queue!))
            ((eq? m 'print-queue) (printf "~a~n" front-ptr))
            (else (error "Undefined operation: " m))))
    dispatch))
(define (empty-queue? queue) (queue 'empty-queue?))
(define (front-queue queue) (queue 'front-queue))
(define (insert-queue! queue item) ((queue 'insert-queue!) item))
(define (delete-queue! queue) (queue 'delete-queue!))
(define (print-queue queue) (queue 'print-queue))
#+end_src

#+name: test-solution-3-22
#+begin_src scheme
<<make-queue-procedure-with-local-state>>
(define q1 (make-queue))
(insert-queue! q1 'a)
(print-queue q1)
(insert-queue! q1 'b)
(print-queue q1)
(delete-queue! q1)
(print-queue q1)
(delete-queue! q1)
(print-queue q1)
#+end_src

#+RESULTS: test-solution-3-22
: (a)
: (a b)
: (b)
: ()

** Exercise 3.23

A /deque/ ("double-ended queue") is a sequence in which items can be inserted and deleted at either the front or the rear. Operations on deques are the constructor ~make-deque~, the predicate ~empty-deque?~, selectors ~front-deque~ and ~rear-deque~, mutators ~front-insert-deque!~, ~rear-insert-deque!~, ~front-delete-deque!~, and ~rear-delete-deque!~. Show how to represent deques using pairs, and give implementations of the operations.[fn:23] All operations should be accomplished in $\Theta(1)$ steps.

*** Solution

#+name: deque-using-pairs
#+begin_src scheme
(define (make-deque) (cons 0 (cons '() '())))
(define (front-ptr deque) (cadr deque))
(define (rear-ptr  deque) (cddr deque))
(define set-front-ptr! set-car!)
(define set-rear-ptr! set-cdr!)
(define (empty-deque? deque) (= (car deque) 0))
(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT called with an empty deque" deque)
      (car (front-ptr deque))))
(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR called with an empty deque" deque)
      (car (rear-ptr deque))))
(define (inc-length deque) (set-car! deque (+ (car deque) 1)))
(define (dec-length deque)
  (if (empty-deque? deque)
      (error "DEC-LENGTH called with an empty deque" deque)
      (set-car! deque (- (car deque) 1))))
(define (front-insert-deque! deque item)
  (set-front-ptr! deque (cons item (front-ptr deque)))
  (set-rear-ptr! deque (append (rear-ptr deque) (list item)))
  (inc-length deque)
  deque)
(define (rear-insert-deque! deque item)
  (set-front-ptr! deque (append (front-ptr deque) (list item)))
  (set-rear-ptr! deque (cons item (rear-ptr deque)))
  (inc-length deque)
  deque)
(define (front-delete-deque! deque)
  (if (empty-deque? deque)
      (error "FRONT-DELETE! called with an empty deque" deque)
      (begin (dec-length deque)
             (set-front-ptr! deque (cdr (front-ptr deque)))
             deque)))
(define (rear-delete-deque! deque)
  (if (empty-deque? deque)
      (error "REAR-DELETE! called with an empty deque" deque)
      (begin (dec-length deque)
             (set-rear-ptr! deque (cdr (rear-ptr deque)))
             deque)))
#+end_src

** Exercise 3.24

In the table implementations above, the keys are tested for equality using ~equal?~ (called by ~assoc~). This is not always the appropriate test. For instance, we might have a table with numeric keys in which we don't need an exact match to the number we're looking up, but only a number within some tolerance of it. Design a table constructor ~make-table~ that takes as an argument a ~same-key?~ procedure that will be used to test "equality" of keys. ~make-table~ should return a ~dispatch~ procedure that can be used to access appropriate ~lookup~ and ~insert!~ procedures for a local table.

*** Solution

#+name: make-table-takes-same-key-predicate
#+begin_src scheme
(define (make-table same-key?)
  (let ((local-table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) false)
            ((same-key? key (caar records)) (car records))
            (else (assoc key (cdr records)))))
    (define (lookup key-1 key-2)
      (let ((subtable
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record
                   (assoc key-2 (cdr subtable))))
              (if record (cdr record) false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record
                   (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1 (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation: TABLE" m))))
    dispatch))
#+end_src

** Exercise 3.25

Generalizing one- and two-dimensional tables, show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different numbers of keys. The ~lookup~ and ~insert!~ procedures should take as input a list of keys used to access the table.

*** Solution

#+name: table-with-arbitrary-keys
#+begin_src scheme
(define (make-table)
  (define local-table (list '*table*))

  (define (assoc key records)
    (cond ((null? records) false)
          ((equal? key (caar records)) (car records))
          (else (assoc key (cdr records)))))

  (define (lookup keys)
    (let ((record (assoc keys (cdr local-table))))
      (if record
          (cdr record)
          false)))

  (define (insert! keys value)
    (let ((record (assoc keys (cdr local-table))))
      (if record
          (set-cdr! record value)
          (set-cdr! local-table (cons (cons keys value) (cdr local-table))))))

  (define (dispatch m)
    (cond ((eq? m 'lookup) lookup)
          ((eq? m 'insert!) insert!)
          ((eq? m 'print) (printf "~a~n" local-table))
          (else (error "Unknown operation -- TABLE" m))))
  dispatch)
(define (insert! table value . keys)
  ((table 'insert!) keys value))
(define (lookup table . keys)
  ((table 'lookup) keys))
(define (print-table table) (table 'print))
#+end_src

#+name: test-solution-3-25
#+begin_src scheme
(require r5rs)
<<table-with-arbitrary-keys>>

(define t (make-table))
(insert! t 1 'a 'b)
(print-table t)
(printf "~a~n" (lookup t 'a 'b))
(insert! t 2 'a)
(print-table t)
(insert! t 3 'a 'b 'c 'd)
(print-table t)
(printf "~a~n" (lookup t 'a 'b 'c 'd))
(printf "~a~n" (lookup t 'a 'b 'c))
#+end_src

#+RESULTS: test-solution-3-25
: {*table* {{a b} . 1}}
: 1
: {*table* {{a} . 2} {{a b} . 1}}
: {*table* {{a b c d} . 3} {{a} . 2} {{a b} . 1}}
: 3
: #f

** Exercise 3.26

To search a table as implemented above, one needs to scan through the list of records. This is basically the unordered list representation of Section 2.3.3. For large tables, it may be more efficient to structure the table in a different manner. Describe a table implementation where the (key, value) records are organized using a binary tree, assuming that keys can be ordered in some way (e.g., numerically or alphabetically). (Compare [[file:chapter-2-exercises.org::*Exercise 2.66][Exercise 2.66]] of [[file:chapter-2-exercises.org][Chapter 2]].)

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.26][sicp-ex-3.26]]
- [[https://wizardbook.wordpress.com/2010/12/16/exercise-3-26/][Exercise 3.26]]

** Exercise 3.27

/Memoization/ (also called /tabulation/) is a technique that enables a procedure to record, in a local table, values that have previously been computed. This technique can make a vast difference in the performance of a program. A memoized procedure maintains a table in which values of previous calls are stored using as keys the arguments that produced the values. When the memoized procedure is asked to compute a value, it first checks the table to see if the value is already there and, if so, just returns that value. Otherwise, it computes the new value in the ordinary way and stores this in the table. As an example of memoization, recall from Section 1.2.2 the exponential process for computing Fibonacci numbers:

#+begin_src scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))
#+end_src

The memoized version of the same procedure is

#+begin_src scheme
(define memo-fib
  (memoize
   (lambda (n)
     (cond ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (memo-fib (- n 1))
                    (memo-fib (- n 2))))))))
#+end_src

where the memoizer is defined as

#+begin_src scheme
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result
             (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
#+end_src

Draw an environment diagram to analyze the computation of ~(memo-fib 3)~. Explain why ~memo-fib~ computes the $n^{th}$ Fibonacci number in a number of steps proportional to $n$. Would the scheme still work if we had simply defined ~memo-fib~ to be ~(memoize fib)~?

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.27][sicp-ex-3.27]]
- [[https://wizardbook.wordpress.com/2010/12/17/exercise-3-27/][Exercise 3.27]]

** Exercise 3.28

Define an or-gate as a primitive function box. Your ~or-gate~ constructor should be similar to ~and-gate~.

*** Solution

#+name: or-gate-constructor
#+begin_src scheme
(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value
           (logical-or (get-signal a1) (get-signal a2))))
      (after-delay
       or-gate-delay
       (lambda () (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)
(define (logical-or s1 s2)
  (cond ((or (= s1 1) (= s2 1)) 1)
        ((and (= s1 0) (= s2 0)) 0)
        (else (error "Invalid signals" (list s1 s2)))))
#+end_src

** Exercise 3.29

Another way to construct an or-gate is as a compound digital logic device, built from and-gates and inverters. Define a procedure ~or-gate~ that accomplishes this. What is the delay time of the or-gate in terms of ~and-gate-delay~ and ~inverter-delay~?

*** Solution

#+name: or-gate-built-from-and-gates-inverters
#+begin_src scheme
(define (or-gate a1 a2 output)
  (let ((invert-a1 (make-wire))
        (invert-a2 (make-wire))
        (and-output (make-wire)))
    (inverter a1 invert-a1)
    (inverter a2 invert-a2)
    (and-gate invert-a1 invert-a2 and-output)
    (inverter and-output output))
  'ok)
#+end_src

The delay time of the or-gate is the sum of and-gate-delay plus twice inverter-delay.

** Exercise 3.30

[[https://sarabander.github.io/sicp/html/3_002e3.xhtml#Figure-3_002e27][Figure 3.27]] shows a /ripple-carry adder/ formed by stringing together /n/ full-adders. This is the simplest form of parallel adder for adding two /n/-bit binary numbers. The inputs $A_1,\,A_2,\,A_3,\,\dots,\,A_n$ and $B_1,\,B_2,\,B_3,\,\dots,\,B_n$ are the two binary numbers to be added (each $A_k$ and $B_k$ is a 0 or a 1). The circuit generates $S_1,\,S_2,\,S_3,\,\dots,\,S_n$, the /n/ bits of the sum, and /C/, the carry from the addition. Write a procedure ~ripple-carry-adder~ that generates this circuit. The procedure should take as arguments three lists of /n/ wires each--the $A_k$, the $B_k$, and the $S_k$ --and also another wire /C/. The major drawback of the ripple-carry adder is the need to wait for the carry signals to propagate. What is the delay needed to obtain the complete output from an /n/-bit ripple-carry adder, expressed in terms of the delays for and-gates, or-gates, and inverters?

*** Solution

#+name: ripple-carry-adder-procedure
#+begin_src scheme
(define (ripple-carry-adder a-wires b-wires s-wires c-in)
  (if (null? a-wires)
      'ok
      (let ((c-out (make-wire)))
        (full-adder (car a-wires) (car b-wires) c-in (car s-wires) c-out)
        (ripple-carry-adder (cdr a-wires) (cdr b-wires) (cdr s-wires) c-out))))
#+end_src

\begin{align*}
\textrm{ripple-adder-delay}&=n\times(\textrm{full-adder-delay}) \\
&=n\times(2\times(\textrm{half-adder-delay})+\textrm{or-gate-delay}) \\
&=n\times(2\times(2\times \textrm{and-gate-delay}+\textrm{or-gate-delay}+\textrm{inverter-gate-delay})+\textrm{or-gate-delay}) \\
&=4n\times\textrm{and-gate-delay}+3n\times\textrm{or-gate-delay}+2n\times\textrm{inverter-gate-delay}
\end{align*}

** Exercise 3.31

The internal procedure ~accept-action-procedure!~ defined in ~make-wire~ specifies that when a new action procedure is added to a wire, the procedure is immediately run. Explain why this initialization is necessary. In particular, trace through the half-adder example in the paragraphs above and say how the system's response would differ if we had defined ~accept-action-procedure!~ as

#+begin_src scheme
(define (accept-action-procedure! proc)
  (set! action-procedures
        (cons proc action-procedures)))
#+end_src

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.31][sicp-ex-3.31]]
- [[https://wizardbook.wordpress.com/2010/12/17/exercise-3-31/][Exercise 3.31]]

** Exercise 3.32

The procedures to be run during each time segment of the agenda are kept in a queue. Thus, the procedures for each segment are called in the order in which they were added to the agenda (first in, first out). Explain why this order must be used. In particular, trace the behavior of an and-gate whose inputs change from 0, 1 to 1, 0 in the same segment and say how the behavior would differ if we stored a segment's procedures in an ordinary list, adding and removing procedures only at the front (last in, first out).

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.32][sicp-ex-3.32]]
- [[https://wizardbook.wordpress.com/2010/12/17/exercise-3-32/][Exercise 3.32]]

** Exercise 3.33

Using primitive multiplier, adder, and constant constraints, define a procedure ~averager~ that takes three connectors ~a~, ~b~, and ~c~ as inputs and establishes the constraints that the value of ~c~ is the average of the values of ~a~ and ~b~.

*** Solution

#+name: averager-procedure
#+begin_src scheme
(define (averager a b c)
  (let ((u (make-connector))
        (v (make-connector)))
    (adder a b u)
    (multiplier c v u)
    (constant 2 v)
    'ok))
#+end_src

** Exercise 3.34

Louis Reasoner wants to build a squarer, a constraint device with two terminals such that the value of connector ~b~ on the second terminal will always be the square of the value ~a~ on the first terminal. He proposes the following simple device made from a multiplier:

#+begin_src scheme
(define (squarer a b)
  (multiplier a a b))
#+end_src

There is a serious flaw in this idea. Explain.

*** Solution

Give a value to ~a~, the squarer can produces a value to ~b~. But it doesn't work inverse. Because the ~multiplier~ will check its two factor terminals at first, it passes if ~a~ has value. And if only gives a value to product terminal, it couldn't pass conditions without any value of factor terminals.

** Exercise 3.35

Ben Bitdiddle tells Louis that one way to avoid the trouble in [[*Exercise 3.34][Exercise 3.34]] is to define a squarer as a new primitive constraint. Fill in the missing portions in Ben's outline for a procedure to implement such a constraint:

#+begin_src scheme
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0: SQUARER"
                   (get-value b))
            <alternative1>)
        <alternative2>))
  (define (process-forget-value) <body1>)
  (define (me request) <body2>)
  <rest of definition>
  me)
#+end_src

*** Solution

#+name: squarer-primitive-constraint
#+begin_src scheme
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0: SQUARER"
                   (get-value b))
            (set-value! a (sqrt (get-value b)) me))
        (if (has-value? a)
            (set-value! b (square (get-value a)) me)
            'do-nothing)))
  (define (process-forget-value)
    (forget-value! a me)
    (forget-value! b me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  (process-new-vlaue))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request: SQUARER" request))))
  (connect a me)
  (connect b me)
  me)
#+end_src

** Exercise 3.36

Suppose we evaluate the following sequence of expressions in the global environment:

#+begin_src scheme
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
#+end_src

At some time during evaluation of the ~set-value!~, the following expression from the connector's local procedure is evaluated:

#+begin_src scheme
(for-each-except
 setter inform-about-value constraints)
#+end_src

Draw an environment diagram showing the environment in which the above expression is evaluated.

*** Solution

[[https://wizardbook.wordpress.com/2010/12/17/exercise-3-36][Exercise 3.36]]

** Exercise 3.37

The ~celsius-fahrenheit-converter~ procedure is cumbersome when compared with a more expression-oriented style of definition, such as

#+begin_src scheme
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
#+end_src

Here ~c+~, ~c*~, etc. are the "constraint" versions of the arithmetic operations. For example, ~c+~ takes two connectors as arguments and returns a connector that is related to these by an adder constraint:

#+begin_src scheme
(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
#+end_src

Define analogous procedures ~c-~, ~c*~, ~c/~, and ~cv~ (constant value) that enable us to define compound constraints as in the converter example above.[fn:33]

*** Solution

#+begin_src scheme
(define (c- x y)
  (let ((z (make-connector)))
    (adder y z x)
    z))
(define (c* x y)
  (let ((z (make-connector)))
    (multiplier x y z)
    z))
(define (c/ x y)
  (let ((z (make-connector)))
    (multiplier y z x)
    z))
(define (cv v)
  (let ((z (make-connector)))
    (constant v z)
    z))
#+end_src

** Exercise 3.38

Suppose that Peter, Paul, and Mary share a joint bank account that initially contains $100. Concurrently, Peter deposits $10, Paul withdraws $20, and Mary withdraws half the money in the account, by executing the following commands:

#+begin_src scheme
Peter:  (set! balance (+ balance 10))
Paul:   (set! balance (- balance 20))
Mary:   (set! balance (- balance (/ balance 2)))
#+end_src

a. List all the different possible values for ~balance~ after these three transactions have been completed, assuming that the banking system forces the three processes to run sequentially in some order.
b. What are some other values that could be produced if the system allows the processes to be interleaved? Draw timing diagrams like the one in [[https://sarabander.github.io/sicp/html/3_002e4.xhtml#Figure-3_002e29][Figure 3.29]] to explain how these values can occur.

*** Solution

**** Part a

| Peter | Paul | Mary | Balance |
|-------+------+------+---------|
|     1 |    2 |    3 |      45 |
|     1 |    3 |    2 |      35 |
|     2 |    1 |    3 |      45 |
|     2 |    3 |    1 |      40 |
|     3 |    1 |    2 |      50 |
|     3 |    2 |    1 |      40 |

**** Part b

- [[http://community.schemewiki.org/?sicp-ex-3.38][sicp-ex-3.38]]
- [[https://wizardbook.wordpress.com/2010/12/18/exercise-3-38/][Exercise 3.38]]

** Exercise 3.39

Which of the five possibilities in the parallel execution shown above remain if we instead serialize execution as follows:

#+begin_src scheme
(define x 10)
(define s (make-serializer))
(parallel-execute
 (lambda () (set! x ((s (lambda () (* x x))))))
 (s (lambda () (set! x (+ x 1)))))
#+end_src

*** Solution

Let's set $P_1$ as ~(lambda () (set! x ((s (lambda () (* x x))))))~, $P_2$ as ~(s (lambda () (set! x (+ x 1))))~.

1. $P_1$ then $P_2$: 101
2. $P_2$ then $P_1$: 121
3. $P_1$ but before set to x then $P_2$: 100

** Exercise 3.40

Give all possible values of ~x~ that can result from executing

#+begin_src scheme
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
#+end_src

Which of these possibilities remain if we instead use serialized procedures:

#+begin_src scheme
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
#+end_src

*** Solution

**** Part 1

P1: ~(lambda () (set! x (* x x)))~
P2: ~(lambda () (set! x (* x x x)))~

1. P1 then P2: 1,000,000
2. P2 then P1: 1,000,000
3. P1 but before set x then switch to P2: 100
4. P2 but before set x then switch to P1: 1,000
5. P1 but before access the second x then P2: 10,000
6. P2 but before access the second x then P1: 100,000
7. P2 but before access the third x then P1: 10,000

**** Part 2

1,000,000

** Exercise 3.41

Ben Bitdiddle worries that it would be better to implement the bank account as follows (where the commented line has been changed):

#+begin_src scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance
                     (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected
               (lambda () balance)))) ; serialized
            (else
             (error "Unknown request: MAKE-ACCOUNT"
                    m))))
    dispatch))
#+end_src

because allowing unserialized access to the bank balance can result in anomalous behavior. Do you agree? Is there any scenario that demonstrates Ben's concern?

*** Solution

No. Because getting balance doesn't change the balance value.

** Exercise 3.42

Ben Bitdiddle suggests that it's a waste of time to create a new serialized procedure in response to every ~withdraw~ and ~deposit~ message. He says that ~make-account~ could be changed so that the calls to ~protected~ are done outside the ~dispatch~ procedure. That is, an account would return the same serialized procedure (which was created at the same time as the account) each time it is asked for a withdrawal procedure.

#+begin_src scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else
               (error "Unknown request: MAKE-ACCOUNT"
                      m))))
      dispatch)))
#+end_src

Is this a safe change to make? In particular, is there any difference in what concurrency is allowed by these two versions of ~make-account~?

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.42][sicp-ex-3.42]]
- [[https://wizardbook.wordpress.com/2010/12/18/exercise-3-42/][Exercise 3.42]]

** Exercise 3.43

Suppose that the balances in three accounts start out as $10, $20, and $30, and that multiple processes run, exchanging the balances in the accounts. Argue that if the processes are run sequentially, after any number of concurrent exchanges, the account balances should be $10, $20, and $30 in some order. Draw a timing diagram like the one in [[https://sarabander.github.io/sicp/html/3_002e4.xhtml#Figure-3_002e29][Figure 3.29]] to show how this condition can be violated if the exchanges are implemented using the first version of the account-exchange program in this section. On the other hand, argue that even with this ~exchange~ program, the sum of the balances in the accounts will be preserved. Draw a timing diagram to show how even this condition would be violated if we did not serialize the transactions on individual accounts.

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.43][sicp-ex-3.43]]
- [[https://wizardbook.wordpress.com/2010/12/19/exercise-3-43/][Exercise 3.43]]

** Exercise 3.44

Consider the problem of transferring an amount from one account to another. Ben Bitdiddle claims that this can be accomplished with the following procedure, even if there are multiple people concurrently transferring money among multiple accounts, using any account mechanism that serializes deposit and withdrawal transactions, for example, the version of ~make-account~ in the text above.

#+begin_src scheme
(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
#+end_src

Louis Reasoner claims that there is a problem here, and that we need to use a more sophisticated method, such as the one required for dealing with the exchange problem. Is Louis right? If not, what is the essential difference between the transfer problem and the exchange problem? (You should assume that the balance in ~from-account~ is at least ~amount~.)

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.44][sicp-ex-3.44]]
- [[https://wizardbook.wordpress.com/2010/12/19/exercise-3-44/][Exercise 3.44]]

** Exercise 3.45

Louis Reasoner thinks our bank-account system is unnecessarily complex and error-prone now that deposits and withdrawals aren't automatically serialized. He suggests that ~make-account-and-serializer~ should have exported the serializer (for use by such procedures as ~serialized-exchange~) in addition to (rather than instead of) using it to serialize accounts and deposits as ~make-account~ did. He proposes to redefine accounts as follows:

#+begin_src scheme
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount)) balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
#+end_src

Then deposits are handled as with the original ~make-account~:

#+begin_src scheme
(define (deposit account amount)
  ((account 'deposit) amount))
#+end_src

Explain what is wrong with Louis's reasoning. In particular, consider what happens when ~serialized-exchange~ is called.

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.45][sicp-ex-3.45]]
- [[https://wizardbook.wordpress.com/2010/12/19/exercise-3-45/][Exercise 3.45]]

** Exercise 3.46

Suppose that we implement ~test-and-set!~ using an ordinary procedure as shown in the text, without attempting to make the operation atomic. Draw a timing diagram like the one in [[https://sarabander.github.io/sicp/html/3_002e4.xhtml#Figure-3_002e29][Figure 3.29]] to demonstrate how the mutex implementation can fail by allowing two processes to acquire the mutex at the same time.

*** Solution

#+begin_example
|            P1        Cell         P2              Mutex
|            +-------- false --------+            'released
|            |                       |
|            v                       |
|   Access cell: false               |
|            |                       |
|            v                       |
|   set! cell to true                |
|            |         true          |
|            |                       v
|            |               Access cell: true
|            |                       |
|            |                       v
|            |               test-and-set! pass
|            |                       |
|            |                       v
|            |               acquire mutex        'acquired
v
time
#+end_example

** Exercise 3.47

A semaphore (of size /n/) is a generalization of a mutex. Like a mutex, a semaphore supports acquire and release operations, but it is more general in that up to /n/ processes can acquire it concurrently. Additional processes that attempt to acquire it concurrently. Additional processes that attempt to acquire the semaphore must wait for release operations. Give implementations of semaphores

a. in terms of mutexes
b. in terms of atomic ~test-and-set!~ operations.

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.47][sicp-ex-3.47]]
- [[https://wizardbook.wordpress.com/2010/12/19/exercise-3-47/][Exercise 3.47]]

** Exercise 3.48

Explain in detail why the deadlock-avoidance method described above, (i.e., the accounts are numbered, and each process attempts to acquire the smaller-numbered account first) avoids deadlock in the exchange problem. Rewrite ~serialized-exchange~ to incorporate this idea. (You will also need to modify ~make-account~ so that each account is created with a number, which can be accessed by sending an appropriate message.)

*** Solution

Because the accounts have been numbered, and each process will attempt to acquire the smaller-numbered account first, it ensures both processes will acquire the same account if they want.

#+name: serialized-exchange-avoid-deadlock
#+begin_src scheme
(define (make-account-and-serializer id balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (less-than? other)
    (< id (other 'id)))
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            ((eq? m 'id) id)
            ((eq? m 'less-than?) less-than?)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
(define (smaller a b)
  (if ((a 'less-than?) b) a b))
(define (bigger a b)
  (if ((a 'less-than?) b) b a))
(define (serialized-exchange account1 account2)
  (let ((a (smaller account1 account2))
        (b (bigger account1 account2)))
    (let ((serializer1 (a 'serializer))
          (serializer2 (b 'serializer)))
      ((serializer1 (serializer2 exchange))
       a
       b))))
#+end_src

** Exercise 3.49

Give a scenario where the deadlock-avoidance mechanism described above does not work. (Hint: In the exchange problem, each process knows in advance which accounts it will need to get access to. Consider a situation where a process must get access to some shared resources before it can know which additional shared resources it will require.)

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.49][sicp-ex-3.49]]
- [[https://wizardbook.wordpress.com/2010/12/19/exercise-3-49/][Exercise 3.49]]

** Exercise 3.50

Complete the following definition, which generalizes ~stream-map~ to allow procedures that take multiple arguments, analogous to ~map~ in Section 2.2.1, Footnote 12.

#+begin_src scheme
(define (stream-map proc . argstreams)
  (if (<??> (car argstreams))
      the-empty-stream
      (<??>
       (apply proc (map <??> argstreams))
       (apply stream-map
              (cons proc (map <??> argstreams))))))
#+end_src

*** Solution

#+name: stream-map-procedure
#+begin_src scheme
(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons-stream
       (apply proc (map stream-car argstreams))
       (apply stream-map
              (cons proc (map stream-cdr argstreams))))))
#+end_src

** Exercise 3.51

In order to take a closer look at delayed evaluation, we will use the following procedure, which simply returns its argument after printing it:

#+begin_src scheme
(define (show x)
  (display-line x)
  x)
#+end_src

What does the interpreter print in response to evaluating each expression in the following sequence?[fn:59]

#+begin_src scheme
(define x
  (stream-map show
              (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
#+end_src

*** Solution

#+begin_example
(define x
  (stream-map show
              (stream-enumerate-interval 0 10)))
0

(stream-ref x 5)
1
2
3
4
5

(stream-ref x 7)
6
7
#+end_example

** Exercise 3.52

Consider the sequence of expressions

#+begin_src scheme
(define sum 0)
(define (accum x) (set! sum (+ x sum)) sum)
(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z
  (stream-filter (lambda (x) (= (remainder x 5) 0))
                 seq))
(stream-ref y 7)
(display-stream z)
#+end_src

What is the value of ~sum~ after each of the above expressions is evaluated? What is the printed response to evaluating the ~stream-ref~ and ~display-stream~ expressions? Would these responses differ if we had implemented ~(delay <exp>)~ simply as ~(lambda () <exp>)~ without using the optimization provided by ~memo-proc~? Explain.

*** Solution

#+begin_example
(define sum 0)
;; sum => 0
(define (accum x) (set! sum (+ x sum)) sum)
;; sum => 0
(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))
;; sum => 1
(define y (stream-filter even? seq))
;; sum => 6
(define z
  (stream-filter (lambda (x) (= (remainder x 5) 0))
                 seq))
;; sum => 10
(stream-ref y 7)
;; sum => 136
136
(display-stream z)
;; sum => 210
10
15
45
55
105
120
190
210
'done
#+end_example

- [[http://community.schemewiki.org/?sicp-ex-3.52][sicp-ex-3.52]]
- [[https://wizardbook.wordpress.com/2010/12/20/exercise-3-52/][Exercise 3.52]]

** Exercise 3.53

Without running the program, describe the elements of the stream defined by

#+begin_src scheme
(define s (cons-stream 1 (add-streams s s)))
#+end_src

*** Solution

#+begin_example
  1 2 4 8  16 32 ... = s
  1 2 4 8  16 32 ... = s
1 2 4 8 16 32 64 ... = s
#+end_example

~s~ is a stream of nonnegative powers of 2.

** Exercise 3.54

Define a procedure ~mul-streams~, analogous to ~add-streams~, that produces the elementwise product of its two input streams. Use this together with the stream of ~integers~ to complete the following definition of the stream whose $n^{th}$ element (counting from 0) is $n+1$ factorial:

#+begin_src scheme
(define factorials
  (cons-stream 1 (mul-streams <??> <??>)))
#+end_src

*** Solution

#+name: mul-streams-procedure
#+begin_src scheme
(define (mul-streams s1 s2) (stream-map * s1 s2))
#+end_src

#+name: factorials-stream
#+begin_src scheme
(define factorials
  (cons-stream 1 (mul-streams factorials (stream-cdr integers))))
#+end_src

** Exercise 3.55

Define a procedure ~partial-sums~ that takes as argument a stream $S$ and returns the stream whose elements are $S_0,S_0+S_1,S_0+S_1+S_2,\dots$. For example, ~(partial-sums integers)~ should be the stream $1,3,6,10,15,\dots$.

*** Solution

#+name: partial-sums-procedure
#+begin_src scheme
(define (partial-sums s)
  (add-streams s (cons-stream 0 (partial-sums s))))
#+end_src

** Exercise 3.56

A famous problem, first raised by R. Hamming, is to enumerate, in ascending order with no repetitions, all positive integers with no prime factors other than 2, 3, or 5. One obvious way to do this is to simply test each integer in turn to see whether it has any factors other than 2, 3, and 5. But this is very inefficient, since, as the integers get larger, fewer and fewer of them fit the requirement. As an alternative, let us call the required stream of numbers ~S~ and notice the following facts about it.

+ ~S~ begins with 1.
+ The elements of ~(scale-stream S 2)~ are also elements of ~S~.
+ The same is true for ~(scale-stream S 3)~ and ~(scale-stream 5 S)~.
+ These are all the elements of ~S~.

Now all we have to do is combine elements from these sources. For this we define a procedure ~merge~ that combines two ordered streams into one ordered result stream, eliminating repetitions:

#+begin_src scheme
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream
                   s2car
                   (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1)
                          (stream-cdr s2)))))))))
#+end_src

Then the required stream may be constructed with ~merge~, as follows:

#+begin_src scheme
(define S (cons-stream 1 (merge <??> <??>)))
#+end_src

Fill in the missing expressions in the places marked $\langle??\rangle$ above.

*** Solution

#+name: S-stream
#+begin_src scheme
(define S (cons-stream 1 (merge (merge (scale-stream S 2) (scale-stream S 3))
                                (scale-stream S 5))))
#+end_src

** Exercise 3.57

How many additions are performed when we compute the $n_{th}$ Fibonacci number using the definition of ~fibs~ based on the ~add-streams~ procedure? Show that the number of additions would be exponentially greater if we had implemented ~(delay <exp>)~ simply as ~(lambda () <exp>)~, without using the optimization provided by the ~memo-proc~ procedure described in Section 3.5.1.[fn:64]

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.57][sicp-ex-3.57]]
- [[https://wizardbook.wordpress.com/2010/12/20/exercise-3-57/][Exercise 3.57]]

** Exercise 3.58

Give an interpretation of the stream computed by the following procedure:

#+begin_src scheme
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
#+end_src

(~quotient~ is a primitive that returns the integer quotient of two integers.) What are the successive elements produced by ~(expand 1 7 10)~? What is produced by ~(expand 3 8 10)~?

*** Solution

#+begin_example
(expand 1 7 10) => 1, 4, 2, 8, 5, 7, 1, ...
1.0 / 7 = 0.142857142857...
(expand 3 8 10) => 3, 7, 5, 0, 0, 0, 0, ...
3.0 / 8 = 0.375
#+end_example

The result is the floating-point representation of ~(/ num den)~ with ~radix~ as the base.

** Exercise 3.59

In Section 2.5.3 we saw how to implement a polynomial arithmetic system representing polynomials as lists of terms. In a similar way, we can work with /power series/, such as

\begin{gather*}
e^x=1+x+\frac{x^2}{2}+\frac{x^3}{3\cdot2}+\frac{x^4}{4\cdot3\cdot2}+\dots,\\
\cos x=1-\frac{x^2}{2}+\frac{x^4}{4\cdot3\cdot2}-\dots,\\
\sin x=x-\frac{x^3}{3\cdot2}+\frac{x^5}{5\cdot4\cdot3\cdot2}-\dots
\end{gather*}

represented as infinite streams. We will represent the series $a_0+a_1x+a_2x^2+a_3x^3+\dots$ as the stream whose elements are the coefficients $a_0,a_1,a_2,a_3,\dots$.

a. The integral of the series $a_0+a_1x+a_2x^2+a_3x^3+\dots$ is the series

   $$c+a_0x+\frac{1}{2}a_1x^2+\frac{1}{3}a_2x^3+\frac{1}{4}a_3x^4+\dots,$$

   where $c$ is any constant. Define a procedure ~integrate-series~ that takes as input a stream $a_0,a_1,a_2,a_3,\dots$ representing a power series and returns the stream $a_0,\frac{1}{2}a_1,\frac{1}{3}a_2,\dots$ of coefficients of the non-constant terms of the integral of the series. (Since the result has no constant term, it doesn't represent a power series; when we use ~integrate-series~, we will ~cons~ on the appropriate constant.)

b. The function $x\mapsto e^x$ is its own derivative. This implies that $e^x$ and the integral of $e^x$ are the same series, except for the constant term, which is $e^0=1$. Accordingly, we can generate the series for $e^x$ as

   #+begin_src scheme
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
   #+end_src

   Show how to generate the series for sine and cosine, starting from the facts that the derivative of sine is cosine and the derivative of cosine is the negative of sine:

   #+begin_src scheme
(define cosine-series (cons-stream 1 <??>))
(define sine-series (cons-stream 0 <??>))
   #+end_src

*** Solution

**** Part a

#+name: integrate-series-procedure
#+begin_src scheme
(define (integrate-series s) (stream-map / s integers))
#+end_src

**** Part b

\begin{align*}
\int\sin x&=-\cos x \\
\int\cos x&=\sin x \\
\cos x&=-1\dot\int\sin x \\
\sin x&=\int\cos x
\end{align*}

#+name: cosine-series-procedure
#+begin_src scheme
(define cosine-series
  (cons-stream 1 (scale-stream (integrate-series sine-series) -1)))
#+end_src

#+name: sine-series-procedure
#+begin_src scheme
(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))
#+end_src

** Exercise 3.60

With power series represented as streams of coefficients as in [[*Exercise 3.59][Exercise 3.59]], adding series is implemented by ~add-streams~. Complete the definition of the following procedure for multiplying series:

#+begin_src scheme
(define (mul-series s1 s2)
  (cons-stream <??> (add-streams <??> <??>)))
#+end_src

You can test your procedure by verifying that $\sin^2x+\cos^2x=1$, using the series from [[*Exercise 3.59][Exercise 3.59]].

*** Solution

#+name: mul-series-procedure
#+begin_src scheme
(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1)
                  (stream-car s2))
               (add-streams (scale-stream (stream-cdr s1)
                                          (stream-car s2))
                            (mul-series s1
                                        (stream-cdr s2)))))
#+end_src

** Exercise 3.61

Let $S$ be a power series ([[*Exercise 3.59][Exercise 3.59]]) whose constant term is 1. Suppose we want to find the power series $1/S$, that is, the series $X$ such that $SX=1$. Write $S=1+S_R$ where $S_R$ is the part of $S$ after the constant term. Then we can solve for $X$ as follows:

\begin{align*}
S\cdot X&=1, \\
(1+S_R)\cdot X&=1, \\
X+S_R\cdot X&=1, \\
X&=1-S_R\cdot X.
\end{align*}

In other words, $X$ is the power series whose constant term is 1 and whose higher-order terms are given by the negative of $S_R$ times $X$. Use this idea to write a procedure ~invert-unit-series~ that computes $1/S$ for a power series $S$ with constant term 1. You will need to use ~mul-series~ from [[*Exercise 3.60][Exercise 3.60]].

*** Solution

#+name: invert-unit-series-procedure
#+begin_src scheme
(define (invert-unit-series s)
  (cons-stream 1
               (scale-stream (mul-series (stream-cdr s)
                                         (invert-unit-series s))
                             -1)))
#+end_src

** Exercise 3.62

Use the results of [[*Exercise 3.60][Exercise 3.60]] and [[*Exercise 3.61][Exercise 3.61]] to define a procedure ~div-series~ that divides two power series. ~div-series~ should work for any two series, provided that the denominator series begins with a nonzero constant term. (If the denominator has a zero constant term, then ~div-series~ should signal an error.) Show how to use ~div-series~ together with the result of [[*Exercise 3.59][Exercise 3.59]] to generate the power series for tangent.

*** Solution

#+name: div-series-procedure
#+begin_src scheme
(define (div-series s1 s2)
  (if (zero? (stream-car s2))
      (error "The denominator has a zero constant term: " s2)
      (mul-series s1 (invert-unit-series s2))))
#+end_src

#+name: tangent-series-procedure
#+begin_src scheme
(define tangent-series (div-series sine-series cosine-series))
#+end_src

** Exercise 3.63

Louis Reasoner asks why the ~sqrt-stream~ procedure was not written in the following more straightforward way, without the local variable ~guesses~:

#+begin_src scheme
(define (sqrt-stream x)
  (cons-stream 1.0 (stream-map
                    (lambda (guess)
                      (sqrt-improve guess x))
                    (sqrt-stream x))))
#+end_src

Alyssa P. Hacker replies that this version of the procedure is considerably less efficient because it performs redundant computation. Explain Alyssa's answer. Would the two versions still differ in efficiency if our implementation of ~delay~ used only ~(lambda () <exp>)~ without using the optimization provided by ~memo-proc~ (Section 3.5.1)?

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.63][sicp-ex-3.63]]
- [[https://wizardbook.wordpress.com/2010/12/20/exercise-3-63/][Exercise 3.63]]

** Exercise 3.64

Write a procedure ~stream-limit~ that takes as arguments a stream and a number (the tolerance). It should examine the stream until it finds two successive elements that differ in absolute value by less than the tolerance, and return the second of the two elements. Using this, we could compute square roots up to a given tolerance by

#+begin_src scheme
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
#+end_src

*** Solution

#+name: stream-limit-procedure
#+begin_src scheme
(define (stream-limit s tolerance)
  (let ((s0 (stream-ref s 0))
        (s1 (stream-ref s 1)))
    (if (< (abs (- s0 s1)) tolerance)
        s1
        (stream-limit (stream-cdr s) tolerance))))
#+end_src

** Exercise 3.65

Use the series

$$\ln 2=1-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+\dots$$

to compute three sequences of approximations to the natural logarithm of 2, in the same way we did above for $\pi$. How rapidly do these sequences converge?

*** Solution

#+begin_src scheme
(define (ln2-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (ln2-summands (+ n 1)))))
(define ln2-stream
  (partial-sums (ln2-summands 1)))

(display-stream ln2-stream)
(display-stream (euler-transform ln2-stream))
(display-stream
 (accelerated-sequence euler-transform ln2-stream))
#+end_src

** Exercise 3.66

Examine the stream ~(pairs integers integers)~. Can you make any general comments about the order in which the pairs are placed into the stream? For example, approximately how many pairs precede the pair (1, 100)? the pair (99, 100)? the pair (100, 100)? (If you can make precise mathematical statements here, all the better. But feel free to give more qualitative answers if you find yourself getting bogged down.)

*** Solution

#+begin_example
(show-stream (pairs integers integers) 14)
(1 1) => 1
(1 2) => 2  = (2 - 1) * 2
(2 2)
(1 3) => 4  = (3 - 1) * 2
(2 3)
(1 4) => 6  = (4 - 1) * 2
(3 3)
(1 5) => 8  = (5 - 1) * 2
(2 4)
(1 6) => 10 = (6 - 1) * 2
(3 4)
(1 7) => 12 = (7 - 1) * 2
(2 5)
(1 8) => 14 = (8 - 1) * 2
...
(1 100) => (100 - 1) * 2 = 198, so there are 197 pairs precede (1, 100)

(2 3) => 5  = 2^3 - 2^(2-1) - 1
(3 4) => 11 = 2^4 - 2^(3-1) - 1
(4 5) => 23 = 2^5 - 2^(4-1) - 1
(5 6) => 47 = 2^6 - 2^(5-1) - 1
(6 7) => 95 = 2^7 - 2^(6-1) - 1
...
(99 100) => 2^100 - 2^(99-1) - 1

(2 2) => 3  = 2^2 - 1
(3 3) => 7  = 2^3 - 1
(4 4) => 15 = 2^4 - 1
(5 5) => 31 = 2^5 - 1
(6 6) => 63 = 2^6 - 1
...
(100 100) => 2^100 - 1
#+end_example

** Exercise 3.67

Modify the ~pairs~ procedure so that ~(pairs integers integers)~ will produce the stream of /all/ pairs of integers $(i, j)$ (without the condition $i\le j$). Hint: You will need to mix in an additional stream.

*** Solution

#+name: all-pairs-procedure
#+begin_src scheme
(define (all-pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (interleave
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     (stream-map (lambda (x) (list x (stream-car t)))
                 (stream-cdr s)))
    (all-pairs (stream-cdr s) (stream-cdr t)))))
#+end_src

** Exercise 3.68

Louis Reasoner thinks that building a stream of pairs from three parts is unnecessarily complicated. Instead of separating the pair $(S_0,T_0)$ from the rest of the pairs in the first row, he proposes to work with the whole first row, as follows:

#+begin_src scheme
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
#+end_src

Does this work? Consider what happens if we evaluate ~(pairs integers integers)~ using Louis's definition of ~pairs~.

*** Solution

- [[http://community.schemewiki.org/?sicp-ex-3.68][sicp-ex-3.68]]
- [[https://wizardbook.wordpress.com/2010/12/22/exercise-3-68/][Exercise 3.68]]

** Exercise 3.69

Write a procedure ~triples~ that takes three infinite streams, $S$, $T$, and $U$, and produces the stream of triples $(S_i,T_j,U_k)$ such that $i\le j\le k$. Use ~triples~ to generate the stream of all Pythagorean triples of positive integers, i.e., the triples $(i,j,k)$ such that $i\le j$ and $i^2+j^2=k^2$.

*** Solution

#+name: triples-procedure
#+begin_src scheme
(define (triples s t u)
  (cons-stream
   (list (stream-car s) (stream-car t) (stream-car u))
   (interleave
    (stream-map (lambda (x) (cons (stream-car s) x))
                (stream-cdr (pairs t u)))
    (triples (stream-cdr s)
             (stream-cdr t)
             (stream-cdr u)))))
#+end_src

#+name: pythagorean-triples-procedure
#+begin_src scheme
(define pythagorean-triples
  (stream-filter (lambda (t) (= (+ (square (car t))
                                   (square (cadr t)))
                                (square (caddr t))))
                 (triples integers integers integers)))
#+end_src

** Exercise 3.70

It would be nice to be able to generate streams in which the pairs appear in some useful order, rather than in the order that results from an /ad hoc/ interleaving process. We can use a technique similar to the ~merge~ procedure of [[*Exercise 3.56][Exercise 3.56]], if we define a way to say that one pair of integers is "less than" another. One way to do this is to define a "weighting function" $W(i,j)$ and stipulate that $(i_1,j_1)$ is less than $(i_2,j_2)$ if $W(i_1,j_1)<W(i_2,j_2)$. Write a procedure ~merge-weighted~ that is like ~merge~, except that ~merged-weighted~ takes an additional argument ~weight~, which is a procedure that computes the weight of a pair, and is used to determine the order in which elements should appear in the resulting merged stream.[fn:69] Using this, generalize ~pairs~ to a procedure ~weighted-pairs~ that takes two streams, together with a procedure that computes a weighting function, and generates the stream of pairs, ordered according to weight. Use your procedure to generate

a. the stream of all pairs of positive integers $(i,j)$ with $i\le j$ ordered according to the sum $i+j$,
b. the stream of all pairs of positive integers $(i,j)$ with $i\le j$, where neither $i$ nor $j$ is divisible by 2, 3, or 5, and the pairs are ordered according to the sum $2i+3j+5ij$.

*** Solution

#+name: merge-weighted-procedure
#+begin_src scheme
(define (merge-weighted s1 s2 weight)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (let ((w1 (weight s1car))
                 (w2 (weight s2car)))
             (cond ((< w1 w2)
                    (cons-stream
                     s1car
                     (merge-weighted (stream-cdr s1) s2 weight)))
                   ((> w1 w2)
                    (cons-stream
                     s2car
                     (merge-weighted s1 (stream-cdr s2) weight)))
                   (else
                    (cons-stream
                     s1car
                     (merge-weighted (stream-cdr s1)
                                     (stream-cdr s2)
                                     weight)))))))))
#+end_src

#+name: weighted-pairs-procedure
#+begin_src scheme
(define (weighted-pairs s t weight)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (merge-weighted
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (weighted-pairs (stream-cdr s) (stream-cdr t) weight)
    weight)))
#+end_src

#+begin_src scheme
(define pair-a
  (weighted-pairs integers integers (lambda (p) (apply + p))))
(define (filtered? n)
  (not (or (even? n)
           (zero? (remainder n 3))
           (zero? (remainder n 5)))))
(define filtered-integers
  (stream-filter filtered? integers))
(define (pair-b-weight p)
  (let ((i (car p)) (j (cadr p)))
    (+ (* 2 i) (* 3 j) (* 5 i j))))
(define pair-b
  (weighted-pairs filtered-integers
                  filtered-integers
                  pair-b-weight))
#+end_src

** Exercise 3.71

Numbers that can be expressed as the sum of two cubes in more than one way are sometimes called /Ramanujan numbers/, in honor of the mathematician Srinivasa Ramanujan.[fn:70] Ordered streams of pairs provide an elegant solution to the problem of computing these numbers. To find a number that can be written as the sum of two cubes in two different ways, we need only generate the stream of pairs of integers $(i,j)$ weighted according to the sum $i^3+j^3$ (see [[*Exercise 3.70][Exercise 3.70]]), then search the stream for two consecutive pairs with the same weight. Write a procedure to generate the Ramanujan numbers. The first such number is 1,729. What are the next five?

*** Solution

#+name: ramanujan-numbers-procedure
#+begin_src scheme
(define (scale-pair-sum p scale)
  (+ (scale (car p)) (scale (cadr p))))
(define (cube-sum p)
  (scale-pair-sum p (lambda (x) (* x x x))))
(define (ramanujan numbers)
  (define (stream-cadr s) (stream-car (stream-cdr s)))
  (define (stream-cddr s) (stream-cdr (stream-cdr s)))
  (let ((w1 (cube-sum (stream-car numbers)))
        (w2 (cube-sum (stream-cadr numbers))))
    (if (= w1 w2)
        (cons-stream w1 (ramanujan (stream-cddr numbers)))
        (ramanujan (stream-cdr numbers)))))
(define ramanujan-numbers
  (ramanujan (weighted-pairs integers integers cube-sum)))
#+end_src

** Exercise 3.72

In a similar way to [[*Exercise 3.71][Exercise 3.71]] generate a stream of all numbers that can be written as the sum of two squares in three different ways (showing how they can be so written).

*** Solution

#+begin_src scheme
(define (square-sum p)
  (scale-pair-sum p (lambda (x) (* x x))))
(define (2-squares-3-ways-helper stream)
  (define (stream-cdddr s) (stream-cdr (stream-cdr (stream-cdr s))))
  (let* ((1st (stream-ref stream 0))
         (2nd (stream-ref stream 1))
         (3rd (stream-ref stream 2))
         (w1 (square-sum 1st))
         (w2 (square-sum 2nd))
         (w3 (square-sum 3rd)))
    (if (= w1 w2 w3)
        (cons-stream (list w1 1st 2nd 3rd)
                     (2-squares-3-ways (stream-cdddr stream)))
        (2-squares-3-ways (stream-cdr stream)))))
(define 2-squares-3-ways
  (2-squares-3-ways-helper (weighted-pairs integers integers square-sum)))
#+end_src

** Exercise 3.73

We can model electrical circuits using streams to represent the values of currents or voltages at a sequence of times. For instance, suppose we have an /RC circuit/ consisting of a resistor of resistance /R/ and a capacitor of capacitance /C/ in series. The voltage response $v$ of the circuit to an injected current $i$ is determined by the formula in [[https://sarabander.github.io/sicp/html/3_002e5.xhtml#Figure-3_002e33][Figure 3.33]], whose structure is shown by the accompanying signal-flow diagram.

Write a procedure ~RC~ that models this circuit. ~RC~ should take as inputs the values of $R$, $C$, and $dt$ and should return a procedure that takes as inputs a stream representing the current $i$ and an initial value for the capacitor voltage $v_0$ and produces as output the stream of voltages $v$. For example, you should be able to use $RC$ to model an RC circuit with $R=5$ ohms, $C=1$ farad, and a 0.5-second time step by evaluating ~(define RC1 (RC 5 1 0.5))~. This defines ~RC1~ as a procedure that takes a stream representing the time sequence of currents and an initial capacitor volatage and produces the output stream of voltages.

*** Solution

#+name: rc-procedure
#+begin_src scheme
(define (RC R C dt)
  (lambda (i initial-value)
    (add-streams (scale-stream i R)
                 (integral (scale-stream i (/ 1 C)) initial-value dt))))
#+end_src

** Exercise 3.74

Alyssa P. Hacker is designing a system to process signals coming from physical sensors. One important feature she wishes to produce is a signal that describes the /zero crossings/ of the input signal. That is, the resulting signal should be $+1$ whenever the input signal changes from negative to positive, $-1$ whenever the input signal changes from positive to negative, and $0$ otherwise. (Assume that the sign of a $0$ input is positive.) For example, a typical input signal with its associated zero-crossing signal would be

#+begin_example
... 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 ...
... 0 0  0  0  0   -1   0  0  0   0   1  0 0 ...
#+end_example

In Alyssa's system, the signal from the sensor is represented as a stream ~sense-data~ and the stream ~zero-crossings~ is the corresponding stream of zero crossings. Alyssa first writes a procedure ~sign-change-detector~ that takes two values as arguments and compares the signs of the values to produce an appropriate 0, 1, or - 1. She the constructs her zero-crossing stream as follows:

#+begin_src scheme
(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector
    (stream-car input-stream)
    last-value)
   (make-zero-crossings
    (stream-cdr input-stream)
    (stream-car input-stream))))
(define zero-crossings
  (make-zero-crossings sense-data 0))
#+end_src

Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is approximately equivalent to the following one, which uses the generalized version of ~stream-map~ from [[*Exercise 3.50][Exercise 3.50]]:

#+begin_src scheme
(define zero-crossings
  (stream-map sign-change-detector
              sense-data
              <expression>))
#+end_src

Complete the program by supplying the indicated $\langle expression\rangle$.

*** Solution

#+begin_src scheme
(define zero-crossings
  (stream-map sign-change-detector
              sense-data
              (cons-stream 0 sense-data)))
#+end_src

** Exercise 3.75

Unfortunately, Alyssa's zero-crossing detector in [[*Exercise 3.74][Exercise 3.74]] proves to be insufficient, because the noisy signal from the sensor leads to spurious zero crossings. Lem E. Tweakit, a hardware specialist, suggests that Alyssa smooth the signal to filter out the noise before extracting the zero crossings. Alyssa takes his advice and decides to extract the zero crossings from the signal constructed by averaging each value of the sense data with the previous value. She explains the problem to her assistant, Louis Reasoner, who attempts to implement the idea, altering Alyssa's program as follows:

#+begin_src scheme
(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream)
                    last-value)
                 2)))
    (cons-stream
     (sign-change-detector avpt last-value)
     (make-zero-crossings
      (stream-cdr input-stream) avpt)))
#+end_src

This does not correctly implement Alyssa's plan. Find the bug that Louis has installed and fix it without changing the structure of the program. (Hint: You will need to increase the number of arguments to ~make-zero-crossings~.)

*** Solution

#+begin_src scheme
(define (make-zero-crossings input-stream last-value last-avpt)
  (let ((avpt (/ (+ (stream-car input-stream)
                    last-value)
                 2)))
    (cons-stream
     (sign-change-detector avpt last-avpt)
     (make-zero-crossings
      (stream-cdr input-stream)
      (stream-car input-stream)
      avpt)))
#+end_src

** Exercise 3.76

Eva Lu Ator has a criticism of Louis's approach in [[*Exercise 3.75][Exercise 3.75]]. The program he wrote is not modular, because it intermixes the operation of smoothing with the zero-crossing extraction. For example, the extractor should not have to be changed if Alyssa finds a better way to condition her input signal. Help Louis by writing a procedure ~smooth~ that takes a stream as input and produces a stream in which each element is the average of two successive input stream elements. Then use ~smooth~ as a component to implement the zero-crossing detector in a more modular style.

*** Solution

#+name: smooth-procedure
#+begin_src scheme
(define (smooth s)
  (stream-map (lambda (a b) (/ (+ a b) 2.0)) s (stream-cdr s)))
#+end_src

#+begin_src scheme
(define (make-zero-crossings input-stream last-value)
  (let ((smoothed-stream (smooth input-stream)))
    (stream-map sign-change-detector
                smoothed-stream
                (cons-stream last-value smoothed-stream))))
(define zero-crossings
  (make-zero-crossings sense-data 0))
#+end_src

** Exercise 3.77

The ~integral~ procedure used above was analogous to the "implicit" definition of the infinite stream of integers in Section 3.5.2. Alternatively, we can give a definition of ~integral~ that is more like ~integers-starting-from~ (also in Section 3.5.2):

#+begin_src scheme
(define (integral integrand initial-value dt)
  (cons-stream
   initial-value
   (if (stream-null? integrand)
       the-empty-stream
       (integral (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
#+end_src

When used in systems with loops, this procedure has the same problem as does our original version of ~integral~. Modify the procedure so that it expects the ~integrand~ as a delayed argument and hence can be used in the ~solve~ procedure shown above.

*** Solution

#+begin_src scheme
(define (integral delayed-integrand initial-value dt)
  (cons-stream
   initial-value
   (let ((integrand (force delayed-integrand)))
     (if (stream-null? integrand)
         the-empty-stream
         (integral (stream-cdr integrand)
                   (+ (* dt (stream-car integrand))
                      initial-value)
                   dt)))))
#+end_src

** Exercise 3.78

Consider the problem of designing a signal-processing system to study the homogeneous second-order linear differential equation

$$\frac{d^2y}{dt^2}-a\frac{dy}{dt}-by=0.$$

The output stream, modeling /y/, is generated by a network that contains a loop. This is because the value of $d^2y/dt^2$ depends upon the values of $y$ and $dy/dt$ and both of these are determined by integrating $d^2y/dt^2$. The diagram we would like to encode is shown in [[https://sarabander.github.io/sicp/html/3_002e5.xhtml#Figure-3_002e35][Figure 3.35]]. Write a procedure ~solve-2nd~ that takes as arguments the constants $a$, $b$, and $dt$ and the initial values $y_0$ and $dy_0$ for $y$ and $dy/dt$ and generates the stream of successive values of $y$.

*** Solution

#+name: solve-2nd-procedure
#+begin_src scheme
(define (solve-2nd a b dt y0 dy0)
  (define y (integral (delay dy) y0 dt))
  (define dy (integral (delay ddy) dy0 dt))
  (define ddy (add-stream (scale-stream dy a)
                          (scale-stream y b)))
  y)
#+end_src

** Exercise 3.79

Generalize the ~solve-2nd~ procedure of [[*Exercise 3.78][Exercise 3.78]] so that it can be used to solve general second-order differential equations $d^2y/dt^2=f(dy/dt,y)$.

*** Solution

#+begin_src scheme
(define (general-solve-2nd f dt y0 dy0)
  (define y (integral (delay dy) y0 dt))
  (define dy (integral (delay ddy) dy0 dt))
  (define ddy (stream-map f dy y))
  y)
#+end_src

** Exercise 3.80

A /series RLC circuit/ consists of a resistor, a capacitor, and an inductor connected in series, as shown in [[https://sarabander.github.io/sicp/html/3_002e5.xhtml#Figure-3_002e36][Figure 3.36]]. If $R$, $L$, and $C$ are the resistance, inductance, and capacitance, then the relations between voltage ($v$) and current ($i$) for the three components are described by the equations

\begin{align*}
v_R&=i_RR, & v_L&=L\frac{di_L}{dt}, & i_C&=C\frac{dv_C}{d_t},
\end{align*}

and the circuit connections dictate the relations

\begin{align*}
i_R&=i_L=-i_C, & v_C&=v_L+v_R.
\end{align*}

Combining these equations shows that the state of the circuit (summarized by $v_C$, the voltage across the capacitor, and $i_L$, the current in the inductor) is described by the pair of differential equations

\begin{align*}
\frac{dv_c}{dt}&=-\frac{i_L}{C}, & \frac{di_L}{dt}&=\frac{1}{L}v_C-\frac{R}{L}i_L.
\end{align*}

The signal-flow diagram representing this system of differential equations is shown in [[https://sarabander.github.io/sicp/html/3_002e5.xhtml#Figure-3_002e37][Figure 3.37]].

Write a procedure ~RLC~ that takes as arguments the parameters ~R~, ~L~, and ~C~ of the circuit and the time increment ~dt~.

In a manner similar to that of the ~RC~ procedure of [[*Exercise 3.73][Exercise 3.73]], ~RLC~ should produce a procedure that takes the initial values of the state variables, $v_{C_0}$ and $i_{L_0}$, and produces a pair (using ~cons~) of the streams of states $v_C$ and $i_L$. Using ~RLC~, generate the pair of streams that models the behavior of a series RLC circuit with $R=1$ ohm, $C=0.2$ farad, $L=1$ henry, $dt=0.1$ second, and initial values $i_{L_0}=0$ amps and $v_{C_0}=10$ volts.

*** Solution

#+name: rlc-procedure
#+begin_src scheme
(define (RLC R L C dt)
  (lambda (vc0 il0)
    (define vc (integral (delay dvc) vc0 dt))
    (define dvc (scale-stream (delay il) (/ -1 C)))
    (define il (integral (delay dil) il0 dt))
    (define dil (add-stream (scale-stream (delay il) (/ (- R) L))
                            (scale-stream (delay vc) (/ 1 L))))
    (cons vc il)))
(define rlc ((RLC 1 1 0.2 0.1) 0 10))
#+end_src

** Exercise 3.81

[[*Exercise 3.6][Exercise 3.6]] discussed generalizing the random-number generator to allow one to reset the random-number sequence so as to produce repeatable sequences of "random" numbers. Produce a stream formulation of this same generator that operates on an input stream of requests to ~generate~ a new random number or to ~reset~ the sequence to a specified value and that produces the desired stream of random numbers. Don't use assignment in your solution.

*** Solution

#+begin_src scheme
(define (rand-update x)
  ;; ref: https://en.wikipedia.org/wiki/Linear_congruential_generator
  (let ((a 1103515245)
        (b 12345)
        (m (expt 2 31)))
    (modulo (+ (* a x) b) m)))
(define random-init (rand-update 65536))
(define random-numbers
  (cons-stream
   random-init
   (stream-map rand-update random-numbers)))
(define (rand request-stream)
  (define (rand-iter stream requests)
    (if (stream-null? requests)
        'done
        (let ((request (stream-car requests)))
          (cond ((eq? request 'generate)
                 (cons-stream (stream-car stream)
                              (rand-iter (stream-cdr stream)
                                         (stream-cdr requests))))
                ((eq? request 'reset)
                 (cons-stream (stream-car random-numbers)
                              (rand-iter (stream-cdr random-numbers)
                                         (stream-cdr requests))))
                (else (error "Unknown request: RAND" request))))))
  (rand-iter random-numbers request-stream))
#+end_src

** Exercise 3.82

Redo [[*Exercise 3.5][Exercise 3.5]] on Monte Carlo integration in terms of streams. The stream version of ~estimate-integral~ will not have an argument telling how many trials to perform. Instead, it will product a stream of estimates based on successively more trials.

*** Solution

#+name: estimate-integral-stream-procedure
#+begin_src scheme
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (* (random) range))))
(define (estimate-integral P x1 x2 y1 y2)
  (define experiment-stream
    (cons-stream (P (random-in-range x1 x2) (random-in-range y1 y2))
                 experiment-stream))
  (monte-carlo experiment-stream 0 0))
#+end_src
